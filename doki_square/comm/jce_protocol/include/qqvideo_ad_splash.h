// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 3.1.1.2 by WSRD Tencent.
// Generated from `qqvideo_ad_splash.jce'
// **********************************************************************

#ifndef __QQVIDEO_AD_SPLASH_H_
#define __QQVIDEO_AD_SPLASH_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
using namespace std;
#include "qqvideo_ad_common.h"
#include "qqvideo_ad_inside.h"


namespace jce
{
    enum ESplashAdUIType
    {
        ESplashAdTypeFullScreenPicture = 0,
        ESplashAdTypeVidVideo = 1,
        ESplashAdTypeMraidRichMedia = 2,
    };
    inline string etos(const ESplashAdUIType & e)
    {
        switch(e)
        {
            case ESplashAdTypeFullScreenPicture: return "ESplashAdTypeFullScreenPicture";
            case ESplashAdTypeVidVideo: return "ESplashAdTypeVidVideo";
            case ESplashAdTypeMraidRichMedia: return "ESplashAdTypeMraidRichMedia";
            default: return "";
        }
    }
    inline int stoe(const string & s, ESplashAdUIType & e)
    {
        if(s == "ESplashAdTypeFullScreenPicture")  { e=ESplashAdTypeFullScreenPicture; return 0;}
        if(s == "ESplashAdTypeVidVideo")  { e=ESplashAdTypeVidVideo; return 0;}
        if(s == "ESplashAdTypeMraidRichMedia")  { e=ESplashAdTypeMraidRichMedia; return 0;}

        return -1;
    }

    struct SplashAdUID : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.SplashAdUID";
        }
        static string MD5()
        {
            return "26159cf77dcb9fe1c64b57dae580ccae";
        }
        SplashAdUID()
        :orderSourceType(0),uoid("")
        {
        }
        void resetDefautlt()
        {
            orderSourceType = 0;
            uoid = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(orderSourceType, 0);
            _os.write(uoid, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(orderSourceType, 0, false);
            _is.read(uoid, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(orderSourceType,"orderSourceType");
            _ds.display(uoid,"uoid");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(orderSourceType, true);
            _ds.displaySimple(uoid, false);
            return _os;
        }
    public:
        taf::Int32 orderSourceType;
        std::string uoid;
    };
    inline bool operator==(const SplashAdUID&l, const SplashAdUID&r)
    {
        return l.orderSourceType == r.orderSourceType && l.uoid == r.uoid;
    }
    inline bool operator!=(const SplashAdUID&l, const SplashAdUID&r)
    {
        return !(l == r);
    }

    struct SplashAdPreloadAdProperty : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.SplashAdPreloadAdProperty";
        }
        static string MD5()
        {
            return "0b4482a8ab8ba340773766f7cd94a6cc";
        }
        SplashAdPreloadAdProperty()
        :effectiveTime(""),serverData(""),isIntraAd(0),serverDataEx(""),oid(0),cid(0),rot(""),isSuperPreview(0)
        {
        }
        void resetDefautlt()
        {
            effectiveTime = "";
            serverData = "";
            isIntraAd = 0;
            serverDataEx = "";
            oid = 0;
            cid = 0;
            rot = "";
            isSuperPreview = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(splashUID, 0);
            _os.write(effectiveTime, 1);
            _os.write(serverData, 2);
            _os.write(isIntraAd, 3);
            _os.write(serverDataEx, 4);
            _os.write(oid, 5);
            _os.write(cid, 6);
            _os.write(rot, 7);
            _os.write(isSuperPreview, 8);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(splashUID, 0, false);
            _is.read(effectiveTime, 1, false);
            _is.read(serverData, 2, false);
            _is.read(isIntraAd, 3, false);
            _is.read(serverDataEx, 4, false);
            _is.read(oid, 5, false);
            _is.read(cid, 6, false);
            _is.read(rot, 7, false);
            _is.read(isSuperPreview, 8, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(splashUID,"splashUID");
            _ds.display(effectiveTime,"effectiveTime");
            _ds.display(serverData,"serverData");
            _ds.display(isIntraAd,"isIntraAd");
            _ds.display(serverDataEx,"serverDataEx");
            _ds.display(oid,"oid");
            _ds.display(cid,"cid");
            _ds.display(rot,"rot");
            _ds.display(isSuperPreview,"isSuperPreview");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(splashUID, true);
            _ds.displaySimple(effectiveTime, true);
            _ds.displaySimple(serverData, true);
            _ds.displaySimple(isIntraAd, true);
            _ds.displaySimple(serverDataEx, true);
            _ds.displaySimple(oid, true);
            _ds.displaySimple(cid, true);
            _ds.displaySimple(rot, true);
            _ds.displaySimple(isSuperPreview, false);
            return _os;
        }
    public:
        jce::SplashAdUID splashUID;
        std::string effectiveTime;
        std::string serverData;
        taf::Int32 isIntraAd;
        std::string serverDataEx;
        taf::Int32 oid;
        taf::Int32 cid;
        std::string rot;
        taf::Int32 isSuperPreview;
    };
    inline bool operator==(const SplashAdPreloadAdProperty&l, const SplashAdPreloadAdProperty&r)
    {
        return l.splashUID == r.splashUID && l.effectiveTime == r.effectiveTime && l.serverData == r.serverData && l.isIntraAd == r.isIntraAd && l.serverDataEx == r.serverDataEx && l.oid == r.oid && l.cid == r.cid && l.rot == r.rot && l.isSuperPreview == r.isSuperPreview;
    }
    inline bool operator!=(const SplashAdPreloadAdProperty&l, const SplashAdPreloadAdProperty&r)
    {
        return !(l == r);
    }

    struct SplashAdPreloadIndex : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.SplashAdPreloadIndex";
        }
        static string MD5()
        {
            return "793fb7a687a8c7997b689d6160d6a8e7";
        }
        SplashAdPreloadIndex()
        :dateKey("")
        {
        }
        void resetDefautlt()
        {
            dateKey = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(dateKey, 0);
            _os.write(splashProperties, 1);
            _os.write(firstPlayOrder, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(dateKey, 0, false);
            _is.read(splashProperties, 1, false);
            _is.read(firstPlayOrder, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(dateKey,"dateKey");
            _ds.display(splashProperties,"splashProperties");
            _ds.display(firstPlayOrder,"firstPlayOrder");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(dateKey, true);
            _ds.displaySimple(splashProperties, true);
            _ds.displaySimple(firstPlayOrder, false);
            return _os;
        }
    public:
        std::string dateKey;
        vector<jce::SplashAdPreloadAdProperty> splashProperties;
        jce::SplashAdPreloadAdProperty firstPlayOrder;
    };
    inline bool operator==(const SplashAdPreloadIndex&l, const SplashAdPreloadIndex&r)
    {
        return l.dateKey == r.dateKey && l.splashProperties == r.splashProperties && l.firstPlayOrder == r.firstPlayOrder;
    }
    inline bool operator!=(const SplashAdPreloadIndex&l, const SplashAdPreloadIndex&r)
    {
        return !(l == r);
    }

    struct SplashAdPictureInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.SplashAdPictureInfo";
        }
        static string MD5()
        {
            return "8d61b639cda77ea57102c6b9cbb5aca2";
        }
        SplashAdPictureInfo()
        :picUrl(""),md5(""),time(0)
        {
        }
        void resetDefautlt()
        {
            picUrl = "";
            md5 = "";
            time = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(picUrl, 0);
            _os.write(md5, 1);
            _os.write(time, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(picUrl, 0, false);
            _is.read(md5, 1, false);
            _is.read(time, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(picUrl,"picUrl");
            _ds.display(md5,"md5");
            _ds.display(time,"time");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(picUrl, true);
            _ds.displaySimple(md5, true);
            _ds.displaySimple(time, false);
            return _os;
        }
    public:
        std::string picUrl;
        std::string md5;
        taf::Int32 time;
    };
    inline bool operator==(const SplashAdPictureInfo&l, const SplashAdPictureInfo&r)
    {
        return l.picUrl == r.picUrl && l.md5 == r.md5 && l.time == r.time;
    }
    inline bool operator!=(const SplashAdPictureInfo&l, const SplashAdPictureInfo&r)
    {
        return !(l == r);
    }

    struct SplashAdVideoInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.SplashAdVideoInfo";
        }
        static string MD5()
        {
            return "2d8b9ec5806fee60cfe5371f7ca94b73";
        }
        SplashAdVideoInfo()
        :vid(""),videoUrl(""),time(0),volumn(0),md5(""),fileSize(0)
        {
        }
        void resetDefautlt()
        {
            vid = "";
            videoUrl = "";
            time = 0;
            volumn = 0;
            md5 = "";
            fileSize = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(vid, 0);
            _os.write(videoUrl, 1);
            _os.write(time, 2);
            _os.write(volumn, 3);
            _os.write(md5, 4);
            _os.write(fileSize, 5);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(vid, 0, false);
            _is.read(videoUrl, 1, false);
            _is.read(time, 2, false);
            _is.read(volumn, 3, false);
            _is.read(md5, 4, false);
            _is.read(fileSize, 5, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(vid,"vid");
            _ds.display(videoUrl,"videoUrl");
            _ds.display(time,"time");
            _ds.display(volumn,"volumn");
            _ds.display(md5,"md5");
            _ds.display(fileSize,"fileSize");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(vid, true);
            _ds.displaySimple(videoUrl, true);
            _ds.displaySimple(time, true);
            _ds.displaySimple(volumn, true);
            _ds.displaySimple(md5, true);
            _ds.displaySimple(fileSize, false);
            return _os;
        }
    public:
        std::string vid;
        std::string videoUrl;
        taf::Int32 time;
        taf::Int32 volumn;
        std::string md5;
        taf::Int32 fileSize;
    };
    inline bool operator==(const SplashAdVideoInfo&l, const SplashAdVideoInfo&r)
    {
        return l.vid == r.vid && l.videoUrl == r.videoUrl && l.time == r.time && l.volumn == r.volumn && l.md5 == r.md5 && l.fileSize == r.fileSize;
    }
    inline bool operator!=(const SplashAdVideoInfo&l, const SplashAdVideoInfo&r)
    {
        return !(l == r);
    }

    struct SplashAdMraidRichMediaInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.SplashAdMraidRichMediaInfo";
        }
        static string MD5()
        {
            return "36c2d153bfaace410e59539c658500ea";
        }
        SplashAdMraidRichMediaInfo()
        :resUrl(""),md5(""),time(0),fileSize(0)
        {
        }
        void resetDefautlt()
        {
            resUrl = "";
            md5 = "";
            time = 0;
            fileSize = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(resUrl, 0);
            _os.write(md5, 1);
            _os.write(time, 2);
            _os.write(fileSize, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(resUrl, 0, false);
            _is.read(md5, 1, false);
            _is.read(time, 2, false);
            _is.read(fileSize, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(resUrl,"resUrl");
            _ds.display(md5,"md5");
            _ds.display(time,"time");
            _ds.display(fileSize,"fileSize");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(resUrl, true);
            _ds.displaySimple(md5, true);
            _ds.displaySimple(time, true);
            _ds.displaySimple(fileSize, false);
            return _os;
        }
    public:
        std::string resUrl;
        std::string md5;
        taf::Int32 time;
        taf::Int32 fileSize;
    };
    inline bool operator==(const SplashAdMraidRichMediaInfo&l, const SplashAdMraidRichMediaInfo&r)
    {
        return l.resUrl == r.resUrl && l.md5 == r.md5 && l.time == r.time && l.fileSize == r.fileSize;
    }
    inline bool operator!=(const SplashAdMraidRichMediaInfo&l, const SplashAdMraidRichMediaInfo&r)
    {
        return !(l == r);
    }

    struct SplashUIInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.SplashUIInfo";
        }
        static string MD5()
        {
            return "134316b2de61db41e1e026b4eca1ed63";
        }
        SplashUIInfo()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(pictureInfo, 0);
            _os.write(videoInfo, 1);
            _os.write(richmediaInfo, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(pictureInfo, 0, false);
            _is.read(videoInfo, 1, false);
            _is.read(richmediaInfo, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(pictureInfo,"pictureInfo");
            _ds.display(videoInfo,"videoInfo");
            _ds.display(richmediaInfo,"richmediaInfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(pictureInfo, true);
            _ds.displaySimple(videoInfo, true);
            _ds.displaySimple(richmediaInfo, false);
            return _os;
        }
    public:
        jce::SplashAdPictureInfo pictureInfo;
        jce::SplashAdVideoInfo videoInfo;
        jce::SplashAdMraidRichMediaInfo richmediaInfo;
    };
    inline bool operator==(const SplashUIInfo&l, const SplashUIInfo&r)
    {
        return l.pictureInfo == r.pictureInfo && l.videoInfo == r.videoInfo && l.richmediaInfo == r.richmediaInfo;
    }
    inline bool operator!=(const SplashUIInfo&l, const SplashUIInfo&r)
    {
        return !(l == r);
    }

    struct SplashAdActionBanner : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.SplashAdActionBanner";
        }
        static string MD5()
        {
            return "c4312070e522704045e5b33ce8fa1138";
        }
        SplashAdActionBanner()
        :enable(false),bannerText(""),bannerTextSize(0),bannerTextColor(""),bannerBgColor("")
        {
        }
        void resetDefautlt()
        {
            enable = false;
            bannerText = "";
            bannerTextSize = 0;
            bannerTextColor = "";
            bannerBgColor = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(enable, 0);
            _os.write(bannerText, 1);
            _os.write(bannerTextSize, 2);
            _os.write(bannerTextColor, 3);
            _os.write(bannerBgColor, 4);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(enable, 0, false);
            _is.read(bannerText, 1, false);
            _is.read(bannerTextSize, 2, false);
            _is.read(bannerTextColor, 3, false);
            _is.read(bannerBgColor, 4, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(enable,"enable");
            _ds.display(bannerText,"bannerText");
            _ds.display(bannerTextSize,"bannerTextSize");
            _ds.display(bannerTextColor,"bannerTextColor");
            _ds.display(bannerBgColor,"bannerBgColor");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(enable, true);
            _ds.displaySimple(bannerText, true);
            _ds.displaySimple(bannerTextSize, true);
            _ds.displaySimple(bannerTextColor, true);
            _ds.displaySimple(bannerBgColor, false);
            return _os;
        }
    public:
        taf::Bool enable;
        std::string bannerText;
        taf::Int32 bannerTextSize;
        std::string bannerTextColor;
        std::string bannerBgColor;
    };
    inline bool operator==(const SplashAdActionBanner&l, const SplashAdActionBanner&r)
    {
        return l.enable == r.enable && l.bannerText == r.bannerText && l.bannerTextSize == r.bannerTextSize && l.bannerTextColor == r.bannerTextColor && l.bannerBgColor == r.bannerBgColor;
    }
    inline bool operator!=(const SplashAdActionBanner&l, const SplashAdActionBanner&r)
    {
        return !(l == r);
    }

    struct SplashAdOrderInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.SplashAdOrderInfo";
        }
        static string MD5()
        {
            return "d7a94ac1782e298f14586766d2970ee6";
        }
        SplashAdOrderInfo()
        :splashAdPriceMode(jce::EAdPriceModeCPM),splashDisableIfOffline(0),splashUIType(jce::ESplashAdTypeFullScreenPicture),splashActionType(jce::EAdActionOpenH5),pvLimit(0),pvFcs(0),splashNavTitle(""),splashTitle(""),splashAbstract(""),adSkipText(""),adIconText(""),dspName(""),hideSkipButton(0),soid("")
        {
        }
        void resetDefautlt()
        {
            splashDisableIfOffline = 0;
            pvLimit = 0;
            pvFcs = 0;
            splashNavTitle = "";
            splashTitle = "";
            splashAbstract = "";
            adSkipText = "";
            adIconText = "";
            dspName = "";
            hideSkipButton = 0;
            soid = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(splashUID, 0);
            _os.write((taf::Int32)splashAdPriceMode, 1);
            _os.write(adBaseInfo, 2);
            _os.write(splashDisableIfOffline, 3);
            _os.write((taf::Int32)splashUIType, 4);
            _os.write(splashUIInfo, 5);
            _os.write((taf::Int32)splashActionType, 6);
            _os.write(actionInfo, 7);
            _os.write(shareItem, 8);
            _os.write(pvLimit, 9);
            _os.write(pvFcs, 10);
            _os.write(splashNavTitle, 11);
            _os.write(splashTitle, 12);
            _os.write(splashAbstract, 13);
            _os.write(adSkipText, 14);
            _os.write(adIconText, 15);
            _os.write(dspName, 16);
            _os.write(hideSkipButton, 17);
            _os.write(soid, 18);
            _os.write(adExperiment, 19);
            _os.write(splashActionBanner, 20);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(splashUID, 0, false);
            taf::Int32 eTemp1 = jce::EAdPriceModeCPM;
            _is.read(eTemp1, 1, false);
            splashAdPriceMode = (jce::EAdPriceMode)eTemp1;
            _is.read(adBaseInfo, 2, false);
            _is.read(splashDisableIfOffline, 3, false);
            taf::Int32 eTemp4 = jce::ESplashAdTypeFullScreenPicture;
            _is.read(eTemp4, 4, false);
            splashUIType = (jce::ESplashAdUIType)eTemp4;
            _is.read(splashUIInfo, 5, false);
            taf::Int32 eTemp6 = jce::EAdActionOpenH5;
            _is.read(eTemp6, 6, false);
            splashActionType = (jce::EAdActionType)eTemp6;
            _is.read(actionInfo, 7, false);
            _is.read(shareItem, 8, false);
            _is.read(pvLimit, 9, false);
            _is.read(pvFcs, 10, false);
            _is.read(splashNavTitle, 11, false);
            _is.read(splashTitle, 12, false);
            _is.read(splashAbstract, 13, false);
            _is.read(adSkipText, 14, false);
            _is.read(adIconText, 15, false);
            _is.read(dspName, 16, false);
            _is.read(hideSkipButton, 17, false);
            _is.read(soid, 18, false);
            _is.read(adExperiment, 19, false);
            _is.read(splashActionBanner, 20, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(splashUID,"splashUID");
            _ds.display((taf::Int32)splashAdPriceMode,"splashAdPriceMode");
            _ds.display(adBaseInfo,"adBaseInfo");
            _ds.display(splashDisableIfOffline,"splashDisableIfOffline");
            _ds.display((taf::Int32)splashUIType,"splashUIType");
            _ds.display(splashUIInfo,"splashUIInfo");
            _ds.display((taf::Int32)splashActionType,"splashActionType");
            _ds.display(actionInfo,"actionInfo");
            _ds.display(shareItem,"shareItem");
            _ds.display(pvLimit,"pvLimit");
            _ds.display(pvFcs,"pvFcs");
            _ds.display(splashNavTitle,"splashNavTitle");
            _ds.display(splashTitle,"splashTitle");
            _ds.display(splashAbstract,"splashAbstract");
            _ds.display(adSkipText,"adSkipText");
            _ds.display(adIconText,"adIconText");
            _ds.display(dspName,"dspName");
            _ds.display(hideSkipButton,"hideSkipButton");
            _ds.display(soid,"soid");
            _ds.display(adExperiment,"adExperiment");
            _ds.display(splashActionBanner,"splashActionBanner");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(splashUID, true);
            _ds.displaySimple((taf::Int32)splashAdPriceMode, true);
            _ds.displaySimple(adBaseInfo, true);
            _ds.displaySimple(splashDisableIfOffline, true);
            _ds.displaySimple((taf::Int32)splashUIType, true);
            _ds.displaySimple(splashUIInfo, true);
            _ds.displaySimple((taf::Int32)splashActionType, true);
            _ds.displaySimple(actionInfo, true);
            _ds.displaySimple(shareItem, true);
            _ds.displaySimple(pvLimit, true);
            _ds.displaySimple(pvFcs, true);
            _ds.displaySimple(splashNavTitle, true);
            _ds.displaySimple(splashTitle, true);
            _ds.displaySimple(splashAbstract, true);
            _ds.displaySimple(adSkipText, true);
            _ds.displaySimple(adIconText, true);
            _ds.displaySimple(dspName, true);
            _ds.displaySimple(hideSkipButton, true);
            _ds.displaySimple(soid, true);
            _ds.displaySimple(adExperiment, true);
            _ds.displaySimple(splashActionBanner, false);
            return _os;
        }
    public:
        jce::SplashAdUID splashUID;
        jce::EAdPriceMode splashAdPriceMode;
        jce::AdBaseInfo adBaseInfo;
        taf::Int32 splashDisableIfOffline;
        jce::ESplashAdUIType splashUIType;
        jce::SplashUIInfo splashUIInfo;
        jce::EAdActionType splashActionType;
        jce::AdActionItem actionInfo;
        jce::AdShareItem shareItem;
        taf::Int32 pvLimit;
        taf::Int32 pvFcs;
        std::string splashNavTitle;
        std::string splashTitle;
        std::string splashAbstract;
        std::string adSkipText;
        std::string adIconText;
        std::string dspName;
        taf::Int32 hideSkipButton;
        std::string soid;
        map<std::string, std::string> adExperiment;
        jce::SplashAdActionBanner splashActionBanner;
    };
    inline bool operator==(const SplashAdOrderInfo&l, const SplashAdOrderInfo&r)
    {
        return l.splashUID == r.splashUID && l.splashAdPriceMode == r.splashAdPriceMode && l.adBaseInfo == r.adBaseInfo && l.splashDisableIfOffline == r.splashDisableIfOffline && l.splashUIType == r.splashUIType && l.splashUIInfo == r.splashUIInfo && l.splashActionType == r.splashActionType && l.actionInfo == r.actionInfo && l.shareItem == r.shareItem && l.pvLimit == r.pvLimit && l.pvFcs == r.pvFcs && l.splashNavTitle == r.splashNavTitle && l.splashTitle == r.splashTitle && l.splashAbstract == r.splashAbstract && l.adSkipText == r.adSkipText && l.adIconText == r.adIconText && l.dspName == r.dspName && l.hideSkipButton == r.hideSkipButton && l.soid == r.soid && l.adExperiment == r.adExperiment && l.splashActionBanner == r.splashActionBanner;
    }
    inline bool operator!=(const SplashAdOrderInfo&l, const SplashAdOrderInfo&r)
    {
        return !(l == r);
    }

    struct SplashAdPreloadRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.SplashAdPreloadRequest";
        }
        static string MD5()
        {
            return "afab74fea21e0a4df0e22933c62919cd";
        }
        SplashAdPreloadRequest()
        :screenWidth(0),screenHeight(0),playround(0)
        {
        }
        void resetDefautlt()
        {
            screenWidth = 0;
            screenHeight = 0;
            playround = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(adRequestInfo, 0);
            _os.write(sdkRequestInfo, 1);
            _os.write(platformInfo, 2);
            _os.write(screenWidth, 3);
            _os.write(screenHeight, 4);
            _os.write(playround, 5);
            _os.write(loadedOrderSet, 6);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(adRequestInfo, 0, false);
            _is.read(sdkRequestInfo, 1, false);
            _is.read(platformInfo, 2, false);
            _is.read(screenWidth, 3, false);
            _is.read(screenHeight, 4, false);
            _is.read(playround, 5, false);
            _is.read(loadedOrderSet, 6, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(adRequestInfo,"adRequestInfo");
            _ds.display(sdkRequestInfo,"sdkRequestInfo");
            _ds.display(platformInfo,"platformInfo");
            _ds.display(screenWidth,"screenWidth");
            _ds.display(screenHeight,"screenHeight");
            _ds.display(playround,"playround");
            _ds.display(loadedOrderSet,"loadedOrderSet");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(adRequestInfo, true);
            _ds.displaySimple(sdkRequestInfo, true);
            _ds.displaySimple(platformInfo, true);
            _ds.displaySimple(screenWidth, true);
            _ds.displaySimple(screenHeight, true);
            _ds.displaySimple(playround, true);
            _ds.displaySimple(loadedOrderSet, false);
            return _os;
        }
    public:
        jce::AdRequestInfo adRequestInfo;
        jce::AdSdkRequestInfo sdkRequestInfo;
        jce::AdVideoPlatformInfo platformInfo;
        taf::Int32 screenWidth;
        taf::Int32 screenHeight;
        taf::Int32 playround;
        vector<jce::SplashAdPreloadIndex> loadedOrderSet;
    };
    inline bool operator==(const SplashAdPreloadRequest&l, const SplashAdPreloadRequest&r)
    {
        return l.adRequestInfo == r.adRequestInfo && l.sdkRequestInfo == r.sdkRequestInfo && l.platformInfo == r.platformInfo && l.screenWidth == r.screenWidth && l.screenHeight == r.screenHeight && l.playround == r.playround && l.loadedOrderSet == r.loadedOrderSet;
    }
    inline bool operator!=(const SplashAdPreloadRequest&l, const SplashAdPreloadRequest&r)
    {
        return !(l == r);
    }

    struct SplashAdPreloadResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.SplashAdPreloadResponse";
        }
        static string MD5()
        {
            return "e022b70ea0cf6cc1c3ed6134ac4d59c4";
        }
        SplashAdPreloadResponse()
        :errCode(0),timestamp(0)
        {
        }
        void resetDefautlt()
        {
            errCode = 0;
            timestamp = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(errCode, 0);
            _os.write(sdkResponseInfo, 1);
            _os.write(splashAdPreloadIndices, 2);
            _os.write(splashAdPreloadOrderInfo, 3);
            _os.write(longTermOrders, 4);
            _os.write(timestamp, 5);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errCode, 0, false);
            _is.read(sdkResponseInfo, 1, false);
            _is.read(splashAdPreloadIndices, 2, false);
            _is.read(splashAdPreloadOrderInfo, 3, false);
            _is.read(longTermOrders, 4, false);
            _is.read(timestamp, 5, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(errCode,"errCode");
            _ds.display(sdkResponseInfo,"sdkResponseInfo");
            _ds.display(splashAdPreloadIndices,"splashAdPreloadIndices");
            _ds.display(splashAdPreloadOrderInfo,"splashAdPreloadOrderInfo");
            _ds.display(longTermOrders,"longTermOrders");
            _ds.display(timestamp,"timestamp");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(errCode, true);
            _ds.displaySimple(sdkResponseInfo, true);
            _ds.displaySimple(splashAdPreloadIndices, true);
            _ds.displaySimple(splashAdPreloadOrderInfo, true);
            _ds.displaySimple(longTermOrders, true);
            _ds.displaySimple(timestamp, false);
            return _os;
        }
    public:
        taf::Int32 errCode;
        jce::AdSdkResponseInfo sdkResponseInfo;
        vector<jce::SplashAdPreloadIndex> splashAdPreloadIndices;
        vector<jce::SplashAdOrderInfo> splashAdPreloadOrderInfo;
        vector<jce::SplashAdPreloadAdProperty> longTermOrders;
        taf::Int64 timestamp;
    };
    inline bool operator==(const SplashAdPreloadResponse&l, const SplashAdPreloadResponse&r)
    {
        return l.errCode == r.errCode && l.sdkResponseInfo == r.sdkResponseInfo && l.splashAdPreloadIndices == r.splashAdPreloadIndices && l.splashAdPreloadOrderInfo == r.splashAdPreloadOrderInfo && l.longTermOrders == r.longTermOrders && l.timestamp == r.timestamp;
    }
    inline bool operator!=(const SplashAdPreloadResponse&l, const SplashAdPreloadResponse&r)
    {
        return !(l == r);
    }

    struct SplashAdRealtimePollRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.SplashAdRealtimePollRequest";
        }
        static string MD5()
        {
            return "d31ab8eb36c84882a8ba60c65e94eb24";
        }
        SplashAdRealtimePollRequest()
        :dateKey(""),playround(0),timestamp(0)
        {
        }
        void resetDefautlt()
        {
            dateKey = "";
            playround = 0;
            timestamp = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(adRequestInfo, 0);
            _os.write(sdkRequestInfo, 1);
            _os.write(platformInfo, 2);
            _os.write(dateKey, 3);
            _os.write(orderSet, 4);
            _os.write(longTermOrderSet, 5);
            _os.write(playround, 6);
            _os.write(timestamp, 7);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(adRequestInfo, 0, false);
            _is.read(sdkRequestInfo, 1, false);
            _is.read(platformInfo, 2, false);
            _is.read(dateKey, 3, false);
            _is.read(orderSet, 4, false);
            _is.read(longTermOrderSet, 5, false);
            _is.read(playround, 6, false);
            _is.read(timestamp, 7, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(adRequestInfo,"adRequestInfo");
            _ds.display(sdkRequestInfo,"sdkRequestInfo");
            _ds.display(platformInfo,"platformInfo");
            _ds.display(dateKey,"dateKey");
            _ds.display(orderSet,"orderSet");
            _ds.display(longTermOrderSet,"longTermOrderSet");
            _ds.display(playround,"playround");
            _ds.display(timestamp,"timestamp");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(adRequestInfo, true);
            _ds.displaySimple(sdkRequestInfo, true);
            _ds.displaySimple(platformInfo, true);
            _ds.displaySimple(dateKey, true);
            _ds.displaySimple(orderSet, true);
            _ds.displaySimple(longTermOrderSet, true);
            _ds.displaySimple(playround, true);
            _ds.displaySimple(timestamp, false);
            return _os;
        }
    public:
        jce::AdRequestInfo adRequestInfo;
        jce::AdSdkRequestInfo sdkRequestInfo;
        jce::AdVideoPlatformInfo platformInfo;
        std::string dateKey;
        vector<jce::SplashAdPreloadAdProperty> orderSet;
        vector<jce::SplashAdPreloadAdProperty> longTermOrderSet;
        taf::Int32 playround;
        taf::Int64 timestamp;
    };
    inline bool operator==(const SplashAdRealtimePollRequest&l, const SplashAdRealtimePollRequest&r)
    {
        return l.adRequestInfo == r.adRequestInfo && l.sdkRequestInfo == r.sdkRequestInfo && l.platformInfo == r.platformInfo && l.dateKey == r.dateKey && l.orderSet == r.orderSet && l.longTermOrderSet == r.longTermOrderSet && l.playround == r.playround && l.timestamp == r.timestamp;
    }
    inline bool operator!=(const SplashAdRealtimePollRequest&l, const SplashAdRealtimePollRequest&r)
    {
        return !(l == r);
    }

    struct SplashAdRealtimePollResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.SplashAdRealtimePollResponse";
        }
        static string MD5()
        {
            return "92cd117b5dfdb6270a2ae43dcc45af50";
        }
        SplashAdRealtimePollResponse()
        :errCode(0),dateKey(""),selectedIndex(0),isEmptyReport(false),needUpdateReportInfo(0)
        {
        }
        void resetDefautlt()
        {
            errCode = 0;
            dateKey = "";
            selectedIndex = 0;
            isEmptyReport = false;
            needUpdateReportInfo = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(errCode, 0);
            _os.write(sdkResponseInfo, 1);
            _os.write(dateKey, 2);
            _os.write(uoidSet, 3);
            _os.write(selectedIndex, 4);
            _os.write(isEmptyReport, 5);
            _os.write(needUpdateReportInfo, 6);
            _os.write(updateReportInfo, 7);
            _os.write(adExperiment, 8);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errCode, 0, false);
            _is.read(sdkResponseInfo, 1, false);
            _is.read(dateKey, 2, false);
            _is.read(uoidSet, 3, false);
            _is.read(selectedIndex, 4, false);
            _is.read(isEmptyReport, 5, false);
            _is.read(needUpdateReportInfo, 6, false);
            _is.read(updateReportInfo, 7, false);
            _is.read(adExperiment, 8, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(errCode,"errCode");
            _ds.display(sdkResponseInfo,"sdkResponseInfo");
            _ds.display(dateKey,"dateKey");
            _ds.display(uoidSet,"uoidSet");
            _ds.display(selectedIndex,"selectedIndex");
            _ds.display(isEmptyReport,"isEmptyReport");
            _ds.display(needUpdateReportInfo,"needUpdateReportInfo");
            _ds.display(updateReportInfo,"updateReportInfo");
            _ds.display(adExperiment,"adExperiment");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(errCode, true);
            _ds.displaySimple(sdkResponseInfo, true);
            _ds.displaySimple(dateKey, true);
            _ds.displaySimple(uoidSet, true);
            _ds.displaySimple(selectedIndex, true);
            _ds.displaySimple(isEmptyReport, true);
            _ds.displaySimple(needUpdateReportInfo, true);
            _ds.displaySimple(updateReportInfo, true);
            _ds.displaySimple(adExperiment, false);
            return _os;
        }
    public:
        taf::Int32 errCode;
        jce::AdSdkResponseInfo sdkResponseInfo;
        std::string dateKey;
        vector<jce::SplashAdUID> uoidSet;
        taf::Int32 selectedIndex;
        taf::Bool isEmptyReport;
        taf::Int32 needUpdateReportInfo;
        jce::AdCoreReportInfo updateReportInfo;
        map<std::string, std::string> adExperiment;
    };
    inline bool operator==(const SplashAdRealtimePollResponse&l, const SplashAdRealtimePollResponse&r)
    {
        return l.errCode == r.errCode && l.sdkResponseInfo == r.sdkResponseInfo && l.dateKey == r.dateKey && l.uoidSet == r.uoidSet && l.selectedIndex == r.selectedIndex && l.isEmptyReport == r.isEmptyReport && l.needUpdateReportInfo == r.needUpdateReportInfo && l.updateReportInfo == r.updateReportInfo && l.adExperiment == r.adExperiment;
    }
    inline bool operator!=(const SplashAdRealtimePollResponse&l, const SplashAdRealtimePollResponse&r)
    {
        return !(l == r);
    }


}

#define jce_SplashAdUID_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.orderSourceType,b.orderSourceType);jce_copy_struct(a.uoid,b.uoid);

#define jce_SplashAdPreloadAdProperty_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.splashUID,b.splashUID);jce_copy_struct(a.effectiveTime,b.effectiveTime);jce_copy_struct(a.serverData,b.serverData);jce_copy_struct(a.isIntraAd,b.isIntraAd);jce_copy_struct(a.serverDataEx,b.serverDataEx);jce_copy_struct(a.oid,b.oid);jce_copy_struct(a.cid,b.cid);jce_copy_struct(a.rot,b.rot);jce_copy_struct(a.isSuperPreview,b.isSuperPreview);

#define jce_SplashAdPreloadIndex_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.dateKey,b.dateKey);jce_copy_struct(a.splashProperties,b.splashProperties);jce_copy_struct(a.firstPlayOrder,b.firstPlayOrder);

#define jce_SplashAdPictureInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.picUrl,b.picUrl);jce_copy_struct(a.md5,b.md5);jce_copy_struct(a.time,b.time);

#define jce_SplashAdVideoInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.vid,b.vid);jce_copy_struct(a.videoUrl,b.videoUrl);jce_copy_struct(a.time,b.time);jce_copy_struct(a.volumn,b.volumn);jce_copy_struct(a.md5,b.md5);jce_copy_struct(a.fileSize,b.fileSize);

#define jce_SplashAdMraidRichMediaInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.resUrl,b.resUrl);jce_copy_struct(a.md5,b.md5);jce_copy_struct(a.time,b.time);jce_copy_struct(a.fileSize,b.fileSize);

#define jce_SplashUIInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.pictureInfo,b.pictureInfo);jce_copy_struct(a.videoInfo,b.videoInfo);jce_copy_struct(a.richmediaInfo,b.richmediaInfo);

#define jce_SplashAdActionBanner_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.enable,b.enable);jce_copy_struct(a.bannerText,b.bannerText);jce_copy_struct(a.bannerTextSize,b.bannerTextSize);jce_copy_struct(a.bannerTextColor,b.bannerTextColor);jce_copy_struct(a.bannerBgColor,b.bannerBgColor);

#define jce_SplashAdOrderInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.splashUID,b.splashUID);jce_copy_struct(a.splashAdPriceMode,b.splashAdPriceMode);jce_copy_struct(a.adBaseInfo,b.adBaseInfo);jce_copy_struct(a.splashDisableIfOffline,b.splashDisableIfOffline);jce_copy_struct(a.splashUIType,b.splashUIType);jce_copy_struct(a.splashUIInfo,b.splashUIInfo);jce_copy_struct(a.splashActionType,b.splashActionType);jce_copy_struct(a.actionInfo,b.actionInfo);jce_copy_struct(a.shareItem,b.shareItem);jce_copy_struct(a.pvLimit,b.pvLimit);jce_copy_struct(a.pvFcs,b.pvFcs);jce_copy_struct(a.splashNavTitle,b.splashNavTitle);jce_copy_struct(a.splashTitle,b.splashTitle);jce_copy_struct(a.splashAbstract,b.splashAbstract);jce_copy_struct(a.adSkipText,b.adSkipText);jce_copy_struct(a.adIconText,b.adIconText);jce_copy_struct(a.dspName,b.dspName);jce_copy_struct(a.hideSkipButton,b.hideSkipButton);jce_copy_struct(a.soid,b.soid);jce_copy_struct(a.adExperiment,b.adExperiment);jce_copy_struct(a.splashActionBanner,b.splashActionBanner);

#define jce_SplashAdPreloadRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.adRequestInfo,b.adRequestInfo);jce_copy_struct(a.sdkRequestInfo,b.sdkRequestInfo);jce_copy_struct(a.platformInfo,b.platformInfo);jce_copy_struct(a.screenWidth,b.screenWidth);jce_copy_struct(a.screenHeight,b.screenHeight);jce_copy_struct(a.playround,b.playround);jce_copy_struct(a.loadedOrderSet,b.loadedOrderSet);

#define jce_SplashAdPreloadResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.errCode,b.errCode);jce_copy_struct(a.sdkResponseInfo,b.sdkResponseInfo);jce_copy_struct(a.splashAdPreloadIndices,b.splashAdPreloadIndices);jce_copy_struct(a.splashAdPreloadOrderInfo,b.splashAdPreloadOrderInfo);jce_copy_struct(a.longTermOrders,b.longTermOrders);jce_copy_struct(a.timestamp,b.timestamp);

#define jce_SplashAdRealtimePollRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.adRequestInfo,b.adRequestInfo);jce_copy_struct(a.sdkRequestInfo,b.sdkRequestInfo);jce_copy_struct(a.platformInfo,b.platformInfo);jce_copy_struct(a.dateKey,b.dateKey);jce_copy_struct(a.orderSet,b.orderSet);jce_copy_struct(a.longTermOrderSet,b.longTermOrderSet);jce_copy_struct(a.playround,b.playround);jce_copy_struct(a.timestamp,b.timestamp);

#define jce_SplashAdRealtimePollResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.errCode,b.errCode);jce_copy_struct(a.sdkResponseInfo,b.sdkResponseInfo);jce_copy_struct(a.dateKey,b.dateKey);jce_copy_struct(a.uoidSet,b.uoidSet);jce_copy_struct(a.selectedIndex,b.selectedIndex);jce_copy_struct(a.isEmptyReport,b.isEmptyReport);jce_copy_struct(a.needUpdateReportInfo,b.needUpdateReportInfo);jce_copy_struct(a.updateReportInfo,b.updateReportInfo);jce_copy_struct(a.adExperiment,b.adExperiment);



#endif
