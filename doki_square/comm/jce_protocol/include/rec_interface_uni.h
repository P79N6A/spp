// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 3.1.1.2 by WSRD Tencent.
// Generated from `rec_interface_uni.jce'
// **********************************************************************

#ifndef __REC_INTERFACE_UNI_H_
#define __REC_INTERFACE_UNI_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
using namespace std;


namespace UniRecStruct
{
    struct CommonHeader : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "UniRecStruct.CommonHeader";
        }
        static string MD5()
        {
            return "325d87d477a8cf7a6468ed6bb39da964";
        }
        CommonHeader()
        :seq_num(""),src_key("")
        {
        }
        void resetDefautlt()
        {
            seq_num = "";
            src_key = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(seq_num, 0);
            _os.write(src_key, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(seq_num, 0, true);
            _is.read(src_key, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(seq_num,"seq_num");
            _ds.display(src_key,"src_key");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(seq_num, true);
            _ds.displaySimple(src_key, false);
            return _os;
        }
    public:
        std::string seq_num;
        std::string src_key;
    };
    inline bool operator==(const CommonHeader&l, const CommonHeader&r)
    {
        return l.seq_num == r.seq_num && l.src_key == r.src_key;
    }
    inline bool operator!=(const CommonHeader&l, const CommonHeader&r)
    {
        return !(l == r);
    }

    struct ResponsStatus : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "UniRecStruct.ResponsStatus";
        }
        static string MD5()
        {
            return "26159cf77dcb9fe1c64b57dae580ccae";
        }
        ResponsStatus()
        :rsp_code(0),rsp_msg("")
        {
        }
        void resetDefautlt()
        {
            rsp_code = 0;
            rsp_msg = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(rsp_code, 0);
            _os.write(rsp_msg, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(rsp_code, 0, true);
            _is.read(rsp_msg, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(rsp_code,"rsp_code");
            _ds.display(rsp_msg,"rsp_msg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(rsp_code, true);
            _ds.displaySimple(rsp_msg, false);
            return _os;
        }
    public:
        taf::Int32 rsp_code;
        std::string rsp_msg;
    };
    inline bool operator==(const ResponsStatus&l, const ResponsStatus&r)
    {
        return l.rsp_code == r.rsp_code && l.rsp_msg == r.rsp_msg;
    }
    inline bool operator!=(const ResponsStatus&l, const ResponsStatus&r)
    {
        return !(l == r);
    }

    struct RecContext : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "UniRecStruct.RecContext";
        }
        static string MD5()
        {
            return "120f3655a79fe57de264be3a6bfd2d1d";
        }
        RecContext()
        :rec_scene(0)
        {
        }
        void resetDefautlt()
        {
            rec_scene = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(rec_scene, 0);
            _os.write(ctx_paras, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(rec_scene, 0, true);
            _is.read(ctx_paras, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(rec_scene,"rec_scene");
            _ds.display(ctx_paras,"ctx_paras");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(rec_scene, true);
            _ds.displaySimple(ctx_paras, false);
            return _os;
        }
    public:
        taf::Int32 rec_scene;
        map<std::string, std::string> ctx_paras;
    };
    inline bool operator==(const RecContext&l, const RecContext&r)
    {
        return l.rec_scene == r.rec_scene && l.ctx_paras == r.ctx_paras;
    }
    inline bool operator!=(const RecContext&l, const RecContext&r)
    {
        return !(l == r);
    }

    struct RecItem : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "UniRecStruct.RecItem";
        }
        static string MD5()
        {
            return "709e78518fdfed7b4e582024cc24e5c3";
        }
        RecItem()
        :item_id(""),item_type(0)
        {
        }
        void resetDefautlt()
        {
            item_id = "";
            item_type = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(item_id, 0);
            _os.write(item_type, 1);
            _os.write(item_paras, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(item_id, 0, true);
            _is.read(item_type, 1, true);
            _is.read(item_paras, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(item_id,"item_id");
            _ds.display(item_type,"item_type");
            _ds.display(item_paras,"item_paras");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(item_id, true);
            _ds.displaySimple(item_type, true);
            _ds.displaySimple(item_paras, false);
            return _os;
        }
    public:
        std::string item_id;
        taf::Int32 item_type;
        map<std::string, std::string> item_paras;
    };
    inline bool operator==(const RecItem&l, const RecItem&r)
    {
        return l.item_id == r.item_id && l.item_type == r.item_type && l.item_paras == r.item_paras;
    }
    inline bool operator!=(const RecItem&l, const RecItem&r)
    {
        return !(l == r);
    }

    struct RecModule : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "UniRecStruct.RecModule";
        }
        static string MD5()
        {
            return "bff054bf331aeec8e49140f9f8416e23";
        }
        RecModule()
        :module_id(""),module_type(0)
        {
        }
        void resetDefautlt()
        {
            module_id = "";
            module_type = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(module_id, 0);
            _os.write(module_type, 1);
            _os.write(rec_items, 2);
            _os.write(module_paras, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(module_id, 0, true);
            _is.read(module_type, 1, true);
            _is.read(rec_items, 2, false);
            _is.read(module_paras, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(module_id,"module_id");
            _ds.display(module_type,"module_type");
            _ds.display(rec_items,"rec_items");
            _ds.display(module_paras,"module_paras");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(module_id, true);
            _ds.displaySimple(module_type, true);
            _ds.displaySimple(rec_items, true);
            _ds.displaySimple(module_paras, false);
            return _os;
        }
    public:
        std::string module_id;
        taf::Int32 module_type;
        vector<UniRecStruct::RecItem> rec_items;
        map<std::string, std::string> module_paras;
    };
    inline bool operator==(const RecModule&l, const RecModule&r)
    {
        return l.module_id == r.module_id && l.module_type == r.module_type && l.rec_items == r.rec_items && l.module_paras == r.module_paras;
    }
    inline bool operator!=(const RecModule&l, const RecModule&r)
    {
        return !(l == r);
    }


}

#define UniRecStruct_CommonHeader_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.seq_num,b.seq_num);jce_copy_struct(a.src_key,b.src_key);

#define UniRecStruct_ResponsStatus_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.rsp_code,b.rsp_code);jce_copy_struct(a.rsp_msg,b.rsp_msg);

#define UniRecStruct_RecContext_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.rec_scene,b.rec_scene);jce_copy_struct(a.ctx_paras,b.ctx_paras);

#define UniRecStruct_RecItem_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.item_id,b.item_id);jce_copy_struct(a.item_type,b.item_type);jce_copy_struct(a.item_paras,b.item_paras);

#define UniRecStruct_RecModule_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.module_id,b.module_id);jce_copy_struct(a.module_type,b.module_type);jce_copy_struct(a.rec_items,b.rec_items);jce_copy_struct(a.module_paras,b.module_paras);



namespace UniRecInterface
{
    const taf::Int32 UNI_REC_COMMAND_ID = 63402;

    struct RecReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "UniRecInterface.RecReq";
        }
        static string MD5()
        {
            return "b5b1a6d901b4544b8778e21de9fff3ca";
        }
        RecReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(header, 0);
            _os.write(rec_ctx, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(header, 0, true);
            _is.read(rec_ctx, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(header,"header");
            _ds.display(rec_ctx,"rec_ctx");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(header, true);
            _ds.displaySimple(rec_ctx, false);
            return _os;
        }
    public:
        UniRecStruct::CommonHeader header;
        UniRecStruct::RecContext rec_ctx;
    };
    inline bool operator==(const RecReq&l, const RecReq&r)
    {
        return l.header == r.header && l.rec_ctx == r.rec_ctx;
    }
    inline bool operator!=(const RecReq&l, const RecReq&r)
    {
        return !(l == r);
    }

    struct RecRsp : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "UniRecInterface.RecRsp";
        }
        static string MD5()
        {
            return "a5741b5e054ed3319bc39741c8eb81ec";
        }
        RecRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(header, 0);
            _os.write(status, 1);
            _os.write(rec_modules, 2);
            _os.write(rsp_paras, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(header, 0, true);
            _is.read(status, 1, true);
            _is.read(rec_modules, 2, false);
            _is.read(rsp_paras, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(header,"header");
            _ds.display(status,"status");
            _ds.display(rec_modules,"rec_modules");
            _ds.display(rsp_paras,"rsp_paras");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(header, true);
            _ds.displaySimple(status, true);
            _ds.displaySimple(rec_modules, true);
            _ds.displaySimple(rsp_paras, false);
            return _os;
        }
    public:
        UniRecStruct::CommonHeader header;
        UniRecStruct::ResponsStatus status;
        vector<UniRecStruct::RecModule> rec_modules;
        map<std::string, std::string> rsp_paras;
    };
    inline bool operator==(const RecRsp&l, const RecRsp&r)
    {
        return l.header == r.header && l.status == r.status && l.rec_modules == r.rec_modules && l.rsp_paras == r.rsp_paras;
    }
    inline bool operator!=(const RecRsp&l, const RecRsp&r)
    {
        return !(l == r);
    }


}

#define UniRecInterface_RecReq_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.header,b.header);jce_copy_struct(a.rec_ctx,b.rec_ctx);

#define UniRecInterface_RecRsp_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.header,b.header);jce_copy_struct(a.status,b.status);jce_copy_struct(a.rec_modules,b.rec_modules);jce_copy_struct(a.rsp_paras,b.rsp_paras);



#endif
