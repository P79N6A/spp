// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 3.1.1.2 by WSRD Tencent.
// Generated from `qqvideo_getvinfo.jce'
// **********************************************************************

#ifndef __QQVIDEO_GETVINFO_H_
#define __QQVIDEO_GETVINFO_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
using namespace std;


namespace jce
{
    struct TVK_UserInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.TVK_UserInfo";
        }
        static string MD5()
        {
            return "881f644f03da18cedbff453a56cf77bb";
        }
        TVK_UserInfo()
        :flowID(""),ckey(""),ckeyVersion(""),ckeyRandNum(0),ckeyQuery(""),netType(0),netOperator(0),speed(0),freeISP(0),freeCode(""),freeType(0),authFrom(0),authExt(""),adk(""),encMac(""),privKey("")
        {
        }
        void resetDefautlt()
        {
            flowID = "";
            ckey = "";
            ckeyVersion = "";
            ckeyRandNum = 0;
            ckeyQuery = "";
            netType = 0;
            netOperator = 0;
            speed = 0;
            freeISP = 0;
            freeCode = "";
            freeType = 0;
            authFrom = 0;
            authExt = "";
            adk = "";
            encMac = "";
            privKey = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(flowID, 0);
            _os.write(ckey, 1);
            _os.write(ckeyVersion, 2);
            _os.write(ckeyRandNum, 3);
            _os.write(ckeyQuery, 4);
            _os.write(netType, 5);
            _os.write(netOperator, 6);
            _os.write(speed, 7);
            _os.write(speedList, 8);
            _os.write(freeISP, 9);
            _os.write(freeCode, 10);
            _os.write(freeType, 11);
            _os.write(authFrom, 12);
            _os.write(authExt, 13);
            _os.write(adk, 14);
            _os.write(encMac, 15);
            _os.write(privKey, 16);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(flowID, 0, false);
            _is.read(ckey, 1, true);
            _is.read(ckeyVersion, 2, true);
            _is.read(ckeyRandNum, 3, false);
            _is.read(ckeyQuery, 4, false);
            _is.read(netType, 5, false);
            _is.read(netOperator, 6, false);
            _is.read(speed, 7, false);
            _is.read(speedList, 8, false);
            _is.read(freeISP, 9, false);
            _is.read(freeCode, 10, false);
            _is.read(freeType, 11, false);
            _is.read(authFrom, 12, false);
            _is.read(authExt, 13, false);
            _is.read(adk, 14, false);
            _is.read(encMac, 15, false);
            _is.read(privKey, 16, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(flowID,"flowID");
            _ds.display(ckey,"ckey");
            _ds.display(ckeyVersion,"ckeyVersion");
            _ds.display(ckeyRandNum,"ckeyRandNum");
            _ds.display(ckeyQuery,"ckeyQuery");
            _ds.display(netType,"netType");
            _ds.display(netOperator,"netOperator");
            _ds.display(speed,"speed");
            _ds.display(speedList,"speedList");
            _ds.display(freeISP,"freeISP");
            _ds.display(freeCode,"freeCode");
            _ds.display(freeType,"freeType");
            _ds.display(authFrom,"authFrom");
            _ds.display(authExt,"authExt");
            _ds.display(adk,"adk");
            _ds.display(encMac,"encMac");
            _ds.display(privKey,"privKey");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(flowID, true);
            _ds.displaySimple(ckey, true);
            _ds.displaySimple(ckeyVersion, true);
            _ds.displaySimple(ckeyRandNum, true);
            _ds.displaySimple(ckeyQuery, true);
            _ds.displaySimple(netType, true);
            _ds.displaySimple(netOperator, true);
            _ds.displaySimple(speed, true);
            _ds.displaySimple(speedList, true);
            _ds.displaySimple(freeISP, true);
            _ds.displaySimple(freeCode, true);
            _ds.displaySimple(freeType, true);
            _ds.displaySimple(authFrom, true);
            _ds.displaySimple(authExt, true);
            _ds.displaySimple(adk, true);
            _ds.displaySimple(encMac, true);
            _ds.displaySimple(privKey, false);
            return _os;
        }
    public:
        std::string flowID;
        std::string ckey;
        std::string ckeyVersion;
        taf::Int64 ckeyRandNum;
        std::string ckeyQuery;
        taf::Int32 netType;
        taf::Int32 netOperator;
        taf::Int32 speed;
        vector<taf::Int32> speedList;
        taf::Int32 freeISP;
        std::string freeCode;
        taf::Int32 freeType;
        taf::Int64 authFrom;
        std::string authExt;
        std::string adk;
        std::string encMac;
        std::string privKey;
    };
    inline bool operator==(const TVK_UserInfo&l, const TVK_UserInfo&r)
    {
        return l.flowID == r.flowID && l.ckey == r.ckey && l.ckeyVersion == r.ckeyVersion && l.ckeyRandNum == r.ckeyRandNum && l.ckeyQuery == r.ckeyQuery && l.netType == r.netType && l.netOperator == r.netOperator && l.speed == r.speed && l.speedList == r.speedList && l.freeISP == r.freeISP && l.freeCode == r.freeCode && l.freeType == r.freeType && l.authFrom == r.authFrom && l.authExt == r.authExt && l.adk == r.adk && l.encMac == r.encMac && l.privKey == r.privKey;
    }
    inline bool operator!=(const TVK_UserInfo&l, const TVK_UserInfo&r)
    {
        return !(l == r);
    }

    struct TVK_AppInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.TVK_AppInfo";
        }
        static string MD5()
        {
            return "c50d9736149aabed4544204b01ac81de";
        }
        TVK_AppInfo()
        :platform(0),appVersion(""),incVersion(0),downloadVersion(0),deviceLevel(0),hevcLevel(0),spMP4(0),spHLS(0),spClip(0),spDefn(0),spHTTPs(0),spDRM(0),spAudio(0),spWM(0),spP2P(0),spDirect(0),spVideo(0),spPic(0),spSrt(0)
        {
        }
        void resetDefautlt()
        {
            platform = 0;
            appVersion = "";
            incVersion = 0;
            downloadVersion = 0;
            deviceLevel = 0;
            hevcLevel = 0;
            spMP4 = 0;
            spHLS = 0;
            spClip = 0;
            spDefn = 0;
            spHTTPs = 0;
            spDRM = 0;
            spAudio = 0;
            spWM = 0;
            spP2P = 0;
            spDirect = 0;
            spVideo = 0;
            spPic = 0;
            spSrt = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(platform, 0);
            _os.write(appVersion, 1);
            _os.write(incVersion, 2);
            _os.write(downloadVersion, 3);
            _os.write(deviceLevel, 4);
            _os.write(hevcLevel, 5);
            _os.write(spMP4, 6);
            _os.write(spHLS, 7);
            _os.write(spClip, 8);
            _os.write(spDefn, 9);
            _os.write(spHTTPs, 10);
            _os.write(spDRM, 11);
            _os.write(spAudio, 12);
            _os.write(spWM, 13);
            _os.write(spP2P, 14);
            _os.write(spDirect, 15);
            _os.write(spVideo, 16);
            _os.write(spPic, 17);
            _os.write(spSrt, 18);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(platform, 0, true);
            _is.read(appVersion, 1, true);
            _is.read(incVersion, 2, false);
            _is.read(downloadVersion, 3, false);
            _is.read(deviceLevel, 4, false);
            _is.read(hevcLevel, 5, false);
            _is.read(spMP4, 6, false);
            _is.read(spHLS, 7, false);
            _is.read(spClip, 8, false);
            _is.read(spDefn, 9, false);
            _is.read(spHTTPs, 10, false);
            _is.read(spDRM, 11, false);
            _is.read(spAudio, 12, false);
            _is.read(spWM, 13, false);
            _is.read(spP2P, 14, false);
            _is.read(spDirect, 15, false);
            _is.read(spVideo, 16, false);
            _is.read(spPic, 17, false);
            _is.read(spSrt, 18, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(platform,"platform");
            _ds.display(appVersion,"appVersion");
            _ds.display(incVersion,"incVersion");
            _ds.display(downloadVersion,"downloadVersion");
            _ds.display(deviceLevel,"deviceLevel");
            _ds.display(hevcLevel,"hevcLevel");
            _ds.display(spMP4,"spMP4");
            _ds.display(spHLS,"spHLS");
            _ds.display(spClip,"spClip");
            _ds.display(spDefn,"spDefn");
            _ds.display(spHTTPs,"spHTTPs");
            _ds.display(spDRM,"spDRM");
            _ds.display(spAudio,"spAudio");
            _ds.display(spWM,"spWM");
            _ds.display(spP2P,"spP2P");
            _ds.display(spDirect,"spDirect");
            _ds.display(spVideo,"spVideo");
            _ds.display(spPic,"spPic");
            _ds.display(spSrt,"spSrt");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(platform, true);
            _ds.displaySimple(appVersion, true);
            _ds.displaySimple(incVersion, true);
            _ds.displaySimple(downloadVersion, true);
            _ds.displaySimple(deviceLevel, true);
            _ds.displaySimple(hevcLevel, true);
            _ds.displaySimple(spMP4, true);
            _ds.displaySimple(spHLS, true);
            _ds.displaySimple(spClip, true);
            _ds.displaySimple(spDefn, true);
            _ds.displaySimple(spHTTPs, true);
            _ds.displaySimple(spDRM, true);
            _ds.displaySimple(spAudio, true);
            _ds.displaySimple(spWM, true);
            _ds.displaySimple(spP2P, true);
            _ds.displaySimple(spDirect, true);
            _ds.displaySimple(spVideo, true);
            _ds.displaySimple(spPic, true);
            _ds.displaySimple(spSrt, false);
            return _os;
        }
    public:
        taf::Int64 platform;
        std::string appVersion;
        taf::Int32 incVersion;
        taf::Int32 downloadVersion;
        taf::Int32 deviceLevel;
        taf::Int32 hevcLevel;
        taf::Int32 spMP4;
        taf::Int32 spHLS;
        taf::Int32 spClip;
        taf::Int32 spDefn;
        taf::Int32 spHTTPs;
        taf::Int32 spDRM;
        taf::Int32 spAudio;
        taf::Int32 spWM;
        taf::Int32 spP2P;
        taf::Int32 spDirect;
        taf::Int32 spVideo;
        taf::Int32 spPic;
        taf::Int32 spSrt;
    };
    inline bool operator==(const TVK_AppInfo&l, const TVK_AppInfo&r)
    {
        return l.platform == r.platform && l.appVersion == r.appVersion && l.incVersion == r.incVersion && l.downloadVersion == r.downloadVersion && l.deviceLevel == r.deviceLevel && l.hevcLevel == r.hevcLevel && l.spMP4 == r.spMP4 && l.spHLS == r.spHLS && l.spClip == r.spClip && l.spDefn == r.spDefn && l.spHTTPs == r.spHTTPs && l.spDRM == r.spDRM && l.spAudio == r.spAudio && l.spWM == r.spWM && l.spP2P == r.spP2P && l.spDirect == r.spDirect && l.spVideo == r.spVideo && l.spPic == r.spPic && l.spSrt == r.spSrt;
    }
    inline bool operator!=(const TVK_AppInfo&l, const TVK_AppInfo&r)
    {
        return !(l == r);
    }

    struct TVK_VideoInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.TVK_VideoInfo";
        }
        static string MD5()
        {
            return "04677d9b98e64b0adc8588eb250ae654";
        }
        TVK_VideoInfo()
        :vid(""),link(""),preVid(""),cid(""),defn(""),defnSource(0),defnSwitch(0),format(0),pTime(0),pagePath(""),aTime(0),track(""),scene("")
        {
        }
        void resetDefautlt()
        {
            vid = "";
            link = "";
            preVid = "";
            cid = "";
            defn = "";
            defnSource = 0;
            defnSwitch = 0;
            format = 0;
            pTime = 0;
            pagePath = "";
            aTime = 0;
            track = "";
            scene = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(vid, 0);
            _os.write(link, 1);
            _os.write(preVid, 2);
            _os.write(cid, 3);
            _os.write(defn, 4);
            _os.write(defnSource, 5);
            _os.write(defnSwitch, 6);
            _os.write(format, 7);
            _os.write(pTime, 8);
            _os.write(pagePath, 9);
            _os.write(aTime, 10);
            _os.write(track, 11);
            _os.write(scene, 12);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(vid, 0, true);
            _is.read(link, 1, false);
            _is.read(preVid, 2, false);
            _is.read(cid, 3, false);
            _is.read(defn, 4, false);
            _is.read(defnSource, 5, false);
            _is.read(defnSwitch, 6, false);
            _is.read(format, 7, false);
            _is.read(pTime, 8, false);
            _is.read(pagePath, 9, false);
            _is.read(aTime, 10, false);
            _is.read(track, 11, false);
            _is.read(scene, 12, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(vid,"vid");
            _ds.display(link,"link");
            _ds.display(preVid,"preVid");
            _ds.display(cid,"cid");
            _ds.display(defn,"defn");
            _ds.display(defnSource,"defnSource");
            _ds.display(defnSwitch,"defnSwitch");
            _ds.display(format,"format");
            _ds.display(pTime,"pTime");
            _ds.display(pagePath,"pagePath");
            _ds.display(aTime,"aTime");
            _ds.display(track,"track");
            _ds.display(scene,"scene");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(vid, true);
            _ds.displaySimple(link, true);
            _ds.displaySimple(preVid, true);
            _ds.displaySimple(cid, true);
            _ds.displaySimple(defn, true);
            _ds.displaySimple(defnSource, true);
            _ds.displaySimple(defnSwitch, true);
            _ds.displaySimple(format, true);
            _ds.displaySimple(pTime, true);
            _ds.displaySimple(pagePath, true);
            _ds.displaySimple(aTime, true);
            _ds.displaySimple(track, true);
            _ds.displaySimple(scene, false);
            return _os;
        }
    public:
        std::string vid;
        std::string link;
        std::string preVid;
        std::string cid;
        std::string defn;
        taf::Int32 defnSource;
        taf::Int32 defnSwitch;
        taf::Int32 format;
        taf::Int32 pTime;
        std::string pagePath;
        taf::Int32 aTime;
        std::string track;
        std::string scene;
    };
    inline bool operator==(const TVK_VideoInfo&l, const TVK_VideoInfo&r)
    {
        return l.vid == r.vid && l.link == r.link && l.preVid == r.preVid && l.cid == r.cid && l.defn == r.defn && l.defnSource == r.defnSource && l.defnSwitch == r.defnSwitch && l.format == r.format && l.pTime == r.pTime && l.pagePath == r.pagePath && l.aTime == r.aTime && l.track == r.track && l.scene == r.scene;
    }
    inline bool operator!=(const TVK_VideoInfo&l, const TVK_VideoInfo&r)
    {
        return !(l == r);
    }

    struct TVK_BaseInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.TVK_BaseInfo";
        }
        static string MD5()
        {
            return "087235d5fcc879ac547c7f01a1cb25ef";
        }
        TVK_BaseInfo()
        :em(0),exem(0),message(""),currentTime(0),ckeyRandNum(""),userIp(""),country(""),province(""),city(""),isp(""),retry(0),testID(0)
        {
        }
        void resetDefautlt()
        {
            em = 0;
            exem = 0;
            message = "";
            currentTime = 0;
            ckeyRandNum = "";
            userIp = "";
            country = "";
            province = "";
            city = "";
            isp = "";
            retry = 0;
            testID = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(em, 0);
            _os.write(exem, 1);
            _os.write(message, 2);
            _os.write(currentTime, 3);
            _os.write(ckeyRandNum, 4);
            _os.write(userIp, 5);
            _os.write(country, 6);
            _os.write(province, 7);
            _os.write(city, 8);
            _os.write(isp, 9);
            _os.write(retry, 10);
            _os.write(testID, 11);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(em, 0, true);
            _is.read(exem, 1, true);
            _is.read(message, 2, true);
            _is.read(currentTime, 3, true);
            _is.read(ckeyRandNum, 4, true);
            _is.read(userIp, 5, true);
            _is.read(country, 6, true);
            _is.read(province, 7, true);
            _is.read(city, 8, true);
            _is.read(isp, 9, true);
            _is.read(retry, 10, true);
            _is.read(testID, 11, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(em,"em");
            _ds.display(exem,"exem");
            _ds.display(message,"message");
            _ds.display(currentTime,"currentTime");
            _ds.display(ckeyRandNum,"ckeyRandNum");
            _ds.display(userIp,"userIp");
            _ds.display(country,"country");
            _ds.display(province,"province");
            _ds.display(city,"city");
            _ds.display(isp,"isp");
            _ds.display(retry,"retry");
            _ds.display(testID,"testID");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(em, true);
            _ds.displaySimple(exem, true);
            _ds.displaySimple(message, true);
            _ds.displaySimple(currentTime, true);
            _ds.displaySimple(ckeyRandNum, true);
            _ds.displaySimple(userIp, true);
            _ds.displaySimple(country, true);
            _ds.displaySimple(province, true);
            _ds.displaySimple(city, true);
            _ds.displaySimple(isp, true);
            _ds.displaySimple(retry, true);
            _ds.displaySimple(testID, false);
            return _os;
        }
    public:
        taf::Int32 em;
        taf::Int32 exem;
        std::string message;
        taf::Int64 currentTime;
        std::string ckeyRandNum;
        std::string userIp;
        std::string country;
        std::string province;
        std::string city;
        std::string isp;
        taf::Int32 retry;
        taf::Int64 testID;
    };
    inline bool operator==(const TVK_BaseInfo&l, const TVK_BaseInfo&r)
    {
        return l.em == r.em && l.exem == r.exem && l.message == r.message && l.currentTime == r.currentTime && l.ckeyRandNum == r.ckeyRandNum && l.userIp == r.userIp && l.country == r.country && l.province == r.province && l.city == r.city && l.isp == r.isp && l.retry == r.retry && l.testID == r.testID;
    }
    inline bool operator!=(const TVK_BaseInfo&l, const TVK_BaseInfo&r)
    {
        return !(l == r);
    }

    struct TVK_VIDNode : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.TVK_VIDNode";
        }
        static string MD5()
        {
            return "814858134ef94d477badd12aa6e163b3";
        }
        TVK_VIDNode()
        :vid(""),link(""),title(""),status(0),totalTime(0),encID(0),fileKey(""),drmKey(""),privKey(""),mediaType(0),mediaStatus(0),mediaCID(""),limit(0),preview(0),head(0),tail(0),containerType(0),clipNum(0),iFlag(0),action(""),p2p(0),cookieTime(0)
        {
        }
        void resetDefautlt()
        {
            vid = "";
            link = "";
            title = "";
            status = 0;
            totalTime = 0;
            encID = 0;
            fileKey = "";
            drmKey = "";
            privKey = "";
            mediaType = 0;
            mediaStatus = 0;
            mediaCID = "";
            limit = 0;
            preview = 0;
            head = 0;
            tail = 0;
            containerType = 0;
            clipNum = 0;
            iFlag = 0;
            action = "";
            p2p = 0;
            cookieTime = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(vid, 0);
            _os.write(link, 1);
            _os.write(title, 2);
            _os.write(status, 3);
            _os.write(totalTime, 4);
            _os.write(encID, 5);
            _os.write(fileKey, 6);
            _os.write(drmKey, 7);
            _os.write(privKey, 8);
            _os.write(mediaType, 9);
            _os.write(mediaStatus, 10);
            _os.write(mediaCID, 11);
            _os.write(limit, 12);
            _os.write(preview, 13);
            _os.write(head, 14);
            _os.write(tail, 15);
            _os.write(containerType, 16);
            _os.write(clipNum, 17);
            _os.write(iFlag, 18);
            _os.write(action, 19);
            _os.write(p2p, 20);
            _os.write(cookieTime, 21);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(vid, 0, true);
            _is.read(link, 1, true);
            _is.read(title, 2, true);
            _is.read(status, 3, true);
            _is.read(totalTime, 4, false);
            _is.read(encID, 5, true);
            _is.read(fileKey, 6, true);
            _is.read(drmKey, 7, true);
            _is.read(privKey, 8, true);
            _is.read(mediaType, 9, true);
            _is.read(mediaStatus, 10, true);
            _is.read(mediaCID, 11, true);
            _is.read(limit, 12, true);
            _is.read(preview, 13, true);
            _is.read(head, 14, true);
            _is.read(tail, 15, true);
            _is.read(containerType, 16, true);
            _is.read(clipNum, 17, true);
            _is.read(iFlag, 18, true);
            _is.read(action, 19, true);
            _is.read(p2p, 20, true);
            _is.read(cookieTime, 21, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(vid,"vid");
            _ds.display(link,"link");
            _ds.display(title,"title");
            _ds.display(status,"status");
            _ds.display(totalTime,"totalTime");
            _ds.display(encID,"encID");
            _ds.display(fileKey,"fileKey");
            _ds.display(drmKey,"drmKey");
            _ds.display(privKey,"privKey");
            _ds.display(mediaType,"mediaType");
            _ds.display(mediaStatus,"mediaStatus");
            _ds.display(mediaCID,"mediaCID");
            _ds.display(limit,"limit");
            _ds.display(preview,"preview");
            _ds.display(head,"head");
            _ds.display(tail,"tail");
            _ds.display(containerType,"containerType");
            _ds.display(clipNum,"clipNum");
            _ds.display(iFlag,"iFlag");
            _ds.display(action,"action");
            _ds.display(p2p,"p2p");
            _ds.display(cookieTime,"cookieTime");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(vid, true);
            _ds.displaySimple(link, true);
            _ds.displaySimple(title, true);
            _ds.displaySimple(status, true);
            _ds.displaySimple(totalTime, true);
            _ds.displaySimple(encID, true);
            _ds.displaySimple(fileKey, true);
            _ds.displaySimple(drmKey, true);
            _ds.displaySimple(privKey, true);
            _ds.displaySimple(mediaType, true);
            _ds.displaySimple(mediaStatus, true);
            _ds.displaySimple(mediaCID, true);
            _ds.displaySimple(limit, true);
            _ds.displaySimple(preview, true);
            _ds.displaySimple(head, true);
            _ds.displaySimple(tail, true);
            _ds.displaySimple(containerType, true);
            _ds.displaySimple(clipNum, true);
            _ds.displaySimple(iFlag, true);
            _ds.displaySimple(action, true);
            _ds.displaySimple(p2p, true);
            _ds.displaySimple(cookieTime, false);
            return _os;
        }
    public:
        std::string vid;
        std::string link;
        std::string title;
        taf::Int32 status;
        taf::Float totalTime;
        taf::Int32 encID;
        std::string fileKey;
        std::string drmKey;
        std::string privKey;
        taf::Int32 mediaType;
        taf::Int32 mediaStatus;
        std::string mediaCID;
        taf::Int32 limit;
        taf::Int32 preview;
        taf::Int32 head;
        taf::Int32 tail;
        taf::Int32 containerType;
        taf::Int32 clipNum;
        taf::Int32 iFlag;
        std::string action;
        taf::Int32 p2p;
        taf::Int32 cookieTime;
    };
    inline bool operator==(const TVK_VIDNode&l, const TVK_VIDNode&r)
    {
        return l.vid == r.vid && l.link == r.link && l.title == r.title && l.status == r.status && l.totalTime == r.totalTime && l.encID == r.encID && l.fileKey == r.fileKey && l.drmKey == r.drmKey && l.privKey == r.privKey && l.mediaType == r.mediaType && l.mediaStatus == r.mediaStatus && l.mediaCID == r.mediaCID && l.limit == r.limit && l.preview == r.preview && l.head == r.head && l.tail == r.tail && l.containerType == r.containerType && l.clipNum == r.clipNum && l.iFlag == r.iFlag && l.action == r.action && l.p2p == r.p2p && l.cookieTime == r.cookieTime;
    }
    inline bool operator!=(const TVK_VIDNode&l, const TVK_VIDNode&r)
    {
        return !(l == r);
    }

    struct TVK_FormatDetail : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.TVK_FormatDetail";
        }
        static string MD5()
        {
            return "64dde3f13de664d1c9364938ba92af18";
        }
        TVK_FormatDetail()
        :name(""),bitrate(0),height(0),width(0),sha(""),dargType(0)
        {
        }
        void resetDefautlt()
        {
            name = "";
            bitrate = 0;
            height = 0;
            width = 0;
            sha = "";
            dargType = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(name, 0);
            _os.write(bitrate, 1);
            _os.write(height, 2);
            _os.write(width, 3);
            _os.write(sha, 4);
            _os.write(dargType, 5);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(name, 0, true);
            _is.read(bitrate, 1, true);
            _is.read(height, 2, true);
            _is.read(width, 3, true);
            _is.read(sha, 4, true);
            _is.read(dargType, 5, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(name,"name");
            _ds.display(bitrate,"bitrate");
            _ds.display(height,"height");
            _ds.display(width,"width");
            _ds.display(sha,"sha");
            _ds.display(dargType,"dargType");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(name, true);
            _ds.displaySimple(bitrate, true);
            _ds.displaySimple(height, true);
            _ds.displaySimple(width, true);
            _ds.displaySimple(sha, true);
            _ds.displaySimple(dargType, false);
            return _os;
        }
    public:
        std::string name;
        taf::Int32 bitrate;
        taf::Int32 height;
        taf::Int32 width;
        std::string sha;
        taf::Int32 dargType;
    };
    inline bool operator==(const TVK_FormatDetail&l, const TVK_FormatDetail&r)
    {
        return l.name == r.name && l.bitrate == r.bitrate && l.height == r.height && l.width == r.width && l.sha == r.sha && l.dargType == r.dargType;
    }
    inline bool operator!=(const TVK_FormatDetail&l, const TVK_FormatDetail&r)
    {
        return !(l == r);
    }

    struct TVK_FormatNode : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.TVK_FormatNode";
        }
        static string MD5()
        {
            return "495a84fddb4e0b48a0fe3f0b2d9d2d71";
        }
        TVK_FormatNode()
        :selected(0),formatID(0),name(""),cname(""),tag(0),fileSize(0),fps(0),encrypt(0),caption(0),vFormat(0),aFormat(0),convType(0),profile(0)
        {
        }
        void resetDefautlt()
        {
            selected = 0;
            formatID = 0;
            name = "";
            cname = "";
            tag = 0;
            fileSize = 0;
            fps = 0;
            encrypt = 0;
            caption = 0;
            vFormat = 0;
            aFormat = 0;
            convType = 0;
            profile = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(detail, 0);
            _os.write(selected, 1);
            _os.write(formatID, 2);
            _os.write(name, 3);
            _os.write(cname, 4);
            _os.write(tag, 5);
            _os.write(fileSize, 6);
            _os.write(fps, 8);
            _os.write(encrypt, 9);
            _os.write(caption, 10);
            _os.write(vFormat, 11);
            _os.write(aFormat, 12);
            _os.write(convType, 13);
            _os.write(profile, 14);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(detail, 0, false);
            _is.read(selected, 1, true);
            _is.read(formatID, 2, true);
            _is.read(name, 3, true);
            _is.read(cname, 4, true);
            _is.read(tag, 5, true);
            _is.read(fileSize, 6, true);
            _is.read(fps, 8, false);
            _is.read(encrypt, 9, true);
            _is.read(caption, 10, false);
            _is.read(vFormat, 11, false);
            _is.read(aFormat, 12, false);
            _is.read(convType, 13, false);
            _is.read(profile, 14, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(detail,"detail");
            _ds.display(selected,"selected");
            _ds.display(formatID,"formatID");
            _ds.display(name,"name");
            _ds.display(cname,"cname");
            _ds.display(tag,"tag");
            _ds.display(fileSize,"fileSize");
            _ds.display(fps,"fps");
            _ds.display(encrypt,"encrypt");
            _ds.display(caption,"caption");
            _ds.display(vFormat,"vFormat");
            _ds.display(aFormat,"aFormat");
            _ds.display(convType,"convType");
            _ds.display(profile,"profile");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(detail, true);
            _ds.displaySimple(selected, true);
            _ds.displaySimple(formatID, true);
            _ds.displaySimple(name, true);
            _ds.displaySimple(cname, true);
            _ds.displaySimple(tag, true);
            _ds.displaySimple(fileSize, true);
            _ds.displaySimple(fps, true);
            _ds.displaySimple(encrypt, true);
            _ds.displaySimple(caption, true);
            _ds.displaySimple(vFormat, true);
            _ds.displaySimple(aFormat, true);
            _ds.displaySimple(convType, true);
            _ds.displaySimple(profile, false);
            return _os;
        }
    public:
        jce::TVK_FormatDetail detail;
        taf::Int32 selected;
        taf::Int32 formatID;
        std::string name;
        std::string cname;
        taf::Int32 tag;
        taf::Int64 fileSize;
        taf::Float fps;
        taf::Int32 encrypt;
        taf::Int32 caption;
        taf::Int32 vFormat;
        taf::Int32 aFormat;
        taf::Int32 convType;
        taf::Int32 profile;
    };
    inline bool operator==(const TVK_FormatNode&l, const TVK_FormatNode&r)
    {
        return l.detail == r.detail && l.selected == r.selected && l.formatID == r.formatID && l.name == r.name && l.cname == r.cname && l.tag == r.tag && l.fileSize == r.fileSize && l.fps == r.fps && l.encrypt == r.encrypt && l.caption == r.caption && l.vFormat == r.vFormat && l.aFormat == r.aFormat && l.convType == r.convType && l.profile == r.profile;
    }
    inline bool operator!=(const TVK_FormatNode&l, const TVK_FormatNode&r)
    {
        return !(l == r);
    }

    struct TVK_URL : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.TVK_URL";
        }
        static string MD5()
        {
            return "19cfb41a66359c894f1dcce10dba2a65";
        }
        TVK_URL()
        :url(""),vt(0),m3u8("")
        {
        }
        void resetDefautlt()
        {
            url = "";
            vt = 0;
            m3u8 = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(url, 0);
            _os.write(vt, 1);
            _os.write(m3u8, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(url, 0, true);
            _is.read(vt, 1, true);
            _is.read(m3u8, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(url,"url");
            _ds.display(vt,"vt");
            _ds.display(m3u8,"m3u8");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(url, true);
            _ds.displaySimple(vt, true);
            _ds.displaySimple(m3u8, false);
            return _os;
        }
    public:
        std::string url;
        taf::Int32 vt;
        std::string m3u8;
    };
    inline bool operator==(const TVK_URL&l, const TVK_URL&r)
    {
        return l.url == r.url && l.vt == r.vt && l.m3u8 == r.m3u8;
    }
    inline bool operator!=(const TVK_URL&l, const TVK_URL&r)
    {
        return !(l == r);
    }

    struct TVK_URLNode : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.TVK_URLNode";
        }
        static string MD5()
        {
            return "f6e29e56dfdad26097d5ac3d735dc35a";
        }
        TVK_URLNode()
        :fileSize(0),duration(0),md5(""),keyID("")
        {
        }
        void resetDefautlt()
        {
            fileSize = 0;
            duration = 0;
            md5 = "";
            keyID = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(fileSize, 1);
            _os.write(duration, 2);
            _os.write(md5, 3);
            _os.write(keyID, 4);
            _os.write(urlList, 5);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(fileSize, 1, true);
            _is.read(duration, 2, true);
            _is.read(md5, 3, true);
            _is.read(keyID, 4, true);
            _is.read(urlList, 5, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(fileSize,"fileSize");
            _ds.display(duration,"duration");
            _ds.display(md5,"md5");
            _ds.display(keyID,"keyID");
            _ds.display(urlList,"urlList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(fileSize, true);
            _ds.displaySimple(duration, true);
            _ds.displaySimple(md5, true);
            _ds.displaySimple(keyID, true);
            _ds.displaySimple(urlList, false);
            return _os;
        }
    public:
        taf::Int64 fileSize;
        taf::Float duration;
        std::string md5;
        std::string keyID;
        vector<jce::TVK_URL> urlList;
    };
    inline bool operator==(const TVK_URLNode&l, const TVK_URLNode&r)
    {
        return l.fileSize == r.fileSize && l.duration == r.duration && l.md5 == r.md5 && l.keyID == r.keyID && l.urlList == r.urlList;
    }
    inline bool operator!=(const TVK_URLNode&l, const TVK_URLNode&r)
    {
        return !(l == r);
    }

    struct TVK_WatermarkNode : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.TVK_WatermarkNode";
        }
        static string MD5()
        {
            return "7b6f5f1b613bba5ca1685077da0ea486";
        }
        TVK_WatermarkNode()
        :wmID(0),x(0),y(0),w(0),h(0),a(0),fileMD5(""),url("")
        {
        }
        void resetDefautlt()
        {
            wmID = 0;
            x = 0;
            y = 0;
            w = 0;
            h = 0;
            a = 0;
            fileMD5 = "";
            url = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(wmID, 0);
            _os.write(x, 1);
            _os.write(y, 2);
            _os.write(w, 3);
            _os.write(h, 4);
            _os.write(a, 5);
            _os.write(fileMD5, 6);
            _os.write(url, 7);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(wmID, 0, true);
            _is.read(x, 1, true);
            _is.read(y, 2, true);
            _is.read(w, 3, true);
            _is.read(h, 4, true);
            _is.read(a, 5, true);
            _is.read(fileMD5, 6, true);
            _is.read(url, 7, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(wmID,"wmID");
            _ds.display(x,"x");
            _ds.display(y,"y");
            _ds.display(w,"w");
            _ds.display(h,"h");
            _ds.display(a,"a");
            _ds.display(fileMD5,"fileMD5");
            _ds.display(url,"url");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(wmID, true);
            _ds.displaySimple(x, true);
            _ds.displaySimple(y, true);
            _ds.displaySimple(w, true);
            _ds.displaySimple(h, true);
            _ds.displaySimple(a, true);
            _ds.displaySimple(fileMD5, true);
            _ds.displaySimple(url, false);
            return _os;
        }
    public:
        taf::Int64 wmID;
        taf::Int32 x;
        taf::Int32 y;
        taf::Int32 w;
        taf::Int32 h;
        taf::Int32 a;
        std::string fileMD5;
        std::string url;
    };
    inline bool operator==(const TVK_WatermarkNode&l, const TVK_WatermarkNode&r)
    {
        return l.wmID == r.wmID && l.x == r.x && l.y == r.y && l.w == r.w && l.h == r.h && l.a == r.a && l.fileMD5 == r.fileMD5 && l.url == r.url;
    }
    inline bool operator!=(const TVK_WatermarkNode&l, const TVK_WatermarkNode&r)
    {
        return !(l == r);
    }

    struct TVK_PictureNode : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.TVK_PictureNode";
        }
        static string MD5()
        {
            return "8f03190d1058cc48f808f4b84084f924";
        }
        TVK_PictureNode()
        :flag(0),cd(0),h(0),w(0),r(0),c(0)
        {
        }
        void resetDefautlt()
        {
            flag = 0;
            cd = 0;
            h = 0;
            w = 0;
            r = 0;
            c = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(flag, 0);
            _os.write(cd, 1);
            _os.write(h, 2);
            _os.write(w, 3);
            _os.write(r, 4);
            _os.write(c, 5);
            _os.write(urlList, 6);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(flag, 0, true);
            _is.read(cd, 1, true);
            _is.read(h, 2, true);
            _is.read(w, 3, true);
            _is.read(r, 4, true);
            _is.read(c, 5, true);
            _is.read(urlList, 6, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(flag,"flag");
            _ds.display(cd,"cd");
            _ds.display(h,"h");
            _ds.display(w,"w");
            _ds.display(r,"r");
            _ds.display(c,"c");
            _ds.display(urlList,"urlList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(flag, true);
            _ds.displaySimple(cd, true);
            _ds.displaySimple(h, true);
            _ds.displaySimple(w, true);
            _ds.displaySimple(r, true);
            _ds.displaySimple(c, true);
            _ds.displaySimple(urlList, false);
            return _os;
        }
    public:
        taf::Int32 flag;
        taf::Int32 cd;
        taf::Int32 h;
        taf::Int32 w;
        taf::Int32 r;
        taf::Int32 c;
        vector<std::string> urlList;
    };
    inline bool operator==(const TVK_PictureNode&l, const TVK_PictureNode&r)
    {
        return l.flag == r.flag && l.cd == r.cd && l.h == r.h && l.w == r.w && l.r == r.r && l.c == r.c && l.urlList == r.urlList;
    }
    inline bool operator!=(const TVK_PictureNode&l, const TVK_PictureNode&r)
    {
        return !(l == r);
    }

    struct TVK_SoftNode : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.TVK_SoftNode";
        }
        static string MD5()
        {
            return "2151e38bb1fb0c34409354e13bcc9ee2";
        }
        TVK_SoftNode()
        :formatID(0),fileName(""),name("")
        {
        }
        void resetDefautlt()
        {
            formatID = 0;
            fileName = "";
            name = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(formatID, 0);
            _os.write(fileName, 1);
            _os.write(urlList, 2);
            _os.write(name, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(formatID, 0, true);
            _is.read(fileName, 1, true);
            _is.read(urlList, 2, true);
            _is.read(name, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(formatID,"formatID");
            _ds.display(fileName,"fileName");
            _ds.display(urlList,"urlList");
            _ds.display(name,"name");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(formatID, true);
            _ds.displaySimple(fileName, true);
            _ds.displaySimple(urlList, true);
            _ds.displaySimple(name, false);
            return _os;
        }
    public:
        taf::Int32 formatID;
        std::string fileName;
        vector<std::string> urlList;
        std::string name;
    };
    inline bool operator==(const TVK_SoftNode&l, const TVK_SoftNode&r)
    {
        return l.formatID == r.formatID && l.fileName == r.fileName && l.urlList == r.urlList && l.name == r.name;
    }
    inline bool operator!=(const TVK_SoftNode&l, const TVK_SoftNode&r)
    {
        return !(l == r);
    }

    struct TVK_GetInfoRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.TVK_GetInfoRequest";
        }
        static string MD5()
        {
            return "04a84e994c2f9b27751c9007a46056e9";
        }
        TVK_GetInfoRequest()
        :debug("")
        {
        }
        void resetDefautlt()
        {
            debug = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(debug, 0);
            _os.write(user, 1);
            _os.write(app, 2);
            _os.write(video, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(debug, 0, false);
            _is.read(user, 1, true);
            _is.read(app, 2, true);
            _is.read(video, 3, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(debug,"debug");
            _ds.display(user,"user");
            _ds.display(app,"app");
            _ds.display(video,"video");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(debug, true);
            _ds.displaySimple(user, true);
            _ds.displaySimple(app, true);
            _ds.displaySimple(video, false);
            return _os;
        }
    public:
        std::string debug;
        jce::TVK_UserInfo user;
        jce::TVK_AppInfo app;
        jce::TVK_VideoInfo video;
    };
    inline bool operator==(const TVK_GetInfoRequest&l, const TVK_GetInfoRequest&r)
    {
        return l.debug == r.debug && l.user == r.user && l.app == r.app && l.video == r.video;
    }
    inline bool operator!=(const TVK_GetInfoRequest&l, const TVK_GetInfoRequest&r)
    {
        return !(l == r);
    }

    struct TVK_GetInfoResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.TVK_GetInfoResponse";
        }
        static string MD5()
        {
            return "59ef4e4855d28109dcb4a2bb321d9a01";
        }
        TVK_GetInfoResponse()
        :debug("")
        {
        }
        void resetDefautlt()
        {
            debug = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(debug, 0);
            _os.write(baseInfo, 1);
            _os.write(vidNode, 2);
            _os.write(formatList, 3);
            _os.write(urlList, 4);
            _os.write(watermarkList, 5);
            _os.write(pictureList, 6);
            _os.write(softList, 7);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(debug, 0, false);
            _is.read(baseInfo, 1, true);
            _is.read(vidNode, 2, false);
            _is.read(formatList, 3, false);
            _is.read(urlList, 4, false);
            _is.read(watermarkList, 5, false);
            _is.read(pictureList, 6, false);
            _is.read(softList, 7, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(debug,"debug");
            _ds.display(baseInfo,"baseInfo");
            _ds.display(vidNode,"vidNode");
            _ds.display(formatList,"formatList");
            _ds.display(urlList,"urlList");
            _ds.display(watermarkList,"watermarkList");
            _ds.display(pictureList,"pictureList");
            _ds.display(softList,"softList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(debug, true);
            _ds.displaySimple(baseInfo, true);
            _ds.displaySimple(vidNode, true);
            _ds.displaySimple(formatList, true);
            _ds.displaySimple(urlList, true);
            _ds.displaySimple(watermarkList, true);
            _ds.displaySimple(pictureList, true);
            _ds.displaySimple(softList, false);
            return _os;
        }
    public:
        std::string debug;
        jce::TVK_BaseInfo baseInfo;
        jce::TVK_VIDNode vidNode;
        vector<jce::TVK_FormatNode> formatList;
        vector<jce::TVK_URLNode> urlList;
        vector<jce::TVK_WatermarkNode> watermarkList;
        vector<jce::TVK_PictureNode> pictureList;
        vector<jce::TVK_SoftNode> softList;
    };
    inline bool operator==(const TVK_GetInfoResponse&l, const TVK_GetInfoResponse&r)
    {
        return l.debug == r.debug && l.baseInfo == r.baseInfo && l.vidNode == r.vidNode && l.formatList == r.formatList && l.urlList == r.urlList && l.watermarkList == r.watermarkList && l.pictureList == r.pictureList && l.softList == r.softList;
    }
    inline bool operator!=(const TVK_GetInfoResponse&l, const TVK_GetInfoResponse&r)
    {
        return !(l == r);
    }


}

#define jce_TVK_UserInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.flowID,b.flowID);jce_copy_struct(a.ckey,b.ckey);jce_copy_struct(a.ckeyVersion,b.ckeyVersion);jce_copy_struct(a.ckeyRandNum,b.ckeyRandNum);jce_copy_struct(a.ckeyQuery,b.ckeyQuery);jce_copy_struct(a.netType,b.netType);jce_copy_struct(a.netOperator,b.netOperator);jce_copy_struct(a.speed,b.speed);jce_copy_struct(a.speedList,b.speedList);jce_copy_struct(a.freeISP,b.freeISP);jce_copy_struct(a.freeCode,b.freeCode);jce_copy_struct(a.freeType,b.freeType);jce_copy_struct(a.authFrom,b.authFrom);jce_copy_struct(a.authExt,b.authExt);jce_copy_struct(a.adk,b.adk);jce_copy_struct(a.encMac,b.encMac);jce_copy_struct(a.privKey,b.privKey);

#define jce_TVK_AppInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.platform,b.platform);jce_copy_struct(a.appVersion,b.appVersion);jce_copy_struct(a.incVersion,b.incVersion);jce_copy_struct(a.downloadVersion,b.downloadVersion);jce_copy_struct(a.deviceLevel,b.deviceLevel);jce_copy_struct(a.hevcLevel,b.hevcLevel);jce_copy_struct(a.spMP4,b.spMP4);jce_copy_struct(a.spHLS,b.spHLS);jce_copy_struct(a.spClip,b.spClip);jce_copy_struct(a.spDefn,b.spDefn);jce_copy_struct(a.spHTTPs,b.spHTTPs);jce_copy_struct(a.spDRM,b.spDRM);jce_copy_struct(a.spAudio,b.spAudio);jce_copy_struct(a.spWM,b.spWM);jce_copy_struct(a.spP2P,b.spP2P);jce_copy_struct(a.spDirect,b.spDirect);jce_copy_struct(a.spVideo,b.spVideo);jce_copy_struct(a.spPic,b.spPic);jce_copy_struct(a.spSrt,b.spSrt);

#define jce_TVK_VideoInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.vid,b.vid);jce_copy_struct(a.link,b.link);jce_copy_struct(a.preVid,b.preVid);jce_copy_struct(a.cid,b.cid);jce_copy_struct(a.defn,b.defn);jce_copy_struct(a.defnSource,b.defnSource);jce_copy_struct(a.defnSwitch,b.defnSwitch);jce_copy_struct(a.format,b.format);jce_copy_struct(a.pTime,b.pTime);jce_copy_struct(a.pagePath,b.pagePath);jce_copy_struct(a.aTime,b.aTime);jce_copy_struct(a.track,b.track);jce_copy_struct(a.scene,b.scene);

#define jce_TVK_BaseInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.em,b.em);jce_copy_struct(a.exem,b.exem);jce_copy_struct(a.message,b.message);jce_copy_struct(a.currentTime,b.currentTime);jce_copy_struct(a.ckeyRandNum,b.ckeyRandNum);jce_copy_struct(a.userIp,b.userIp);jce_copy_struct(a.country,b.country);jce_copy_struct(a.province,b.province);jce_copy_struct(a.city,b.city);jce_copy_struct(a.isp,b.isp);jce_copy_struct(a.retry,b.retry);jce_copy_struct(a.testID,b.testID);

#define jce_TVK_VIDNode_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.vid,b.vid);jce_copy_struct(a.link,b.link);jce_copy_struct(a.title,b.title);jce_copy_struct(a.status,b.status);jce_copy_struct(a.totalTime,b.totalTime);jce_copy_struct(a.encID,b.encID);jce_copy_struct(a.fileKey,b.fileKey);jce_copy_struct(a.drmKey,b.drmKey);jce_copy_struct(a.privKey,b.privKey);jce_copy_struct(a.mediaType,b.mediaType);jce_copy_struct(a.mediaStatus,b.mediaStatus);jce_copy_struct(a.mediaCID,b.mediaCID);jce_copy_struct(a.limit,b.limit);jce_copy_struct(a.preview,b.preview);jce_copy_struct(a.head,b.head);jce_copy_struct(a.tail,b.tail);jce_copy_struct(a.containerType,b.containerType);jce_copy_struct(a.clipNum,b.clipNum);jce_copy_struct(a.iFlag,b.iFlag);jce_copy_struct(a.action,b.action);jce_copy_struct(a.p2p,b.p2p);jce_copy_struct(a.cookieTime,b.cookieTime);

#define jce_TVK_FormatDetail_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.name,b.name);jce_copy_struct(a.bitrate,b.bitrate);jce_copy_struct(a.height,b.height);jce_copy_struct(a.width,b.width);jce_copy_struct(a.sha,b.sha);jce_copy_struct(a.dargType,b.dargType);

#define jce_TVK_FormatNode_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.detail,b.detail);jce_copy_struct(a.selected,b.selected);jce_copy_struct(a.formatID,b.formatID);jce_copy_struct(a.name,b.name);jce_copy_struct(a.cname,b.cname);jce_copy_struct(a.tag,b.tag);jce_copy_struct(a.fileSize,b.fileSize);jce_copy_struct(a.fps,b.fps);jce_copy_struct(a.encrypt,b.encrypt);jce_copy_struct(a.caption,b.caption);jce_copy_struct(a.vFormat,b.vFormat);jce_copy_struct(a.aFormat,b.aFormat);jce_copy_struct(a.convType,b.convType);jce_copy_struct(a.profile,b.profile);

#define jce_TVK_URL_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.url,b.url);jce_copy_struct(a.vt,b.vt);jce_copy_struct(a.m3u8,b.m3u8);

#define jce_TVK_URLNode_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.fileSize,b.fileSize);jce_copy_struct(a.duration,b.duration);jce_copy_struct(a.md5,b.md5);jce_copy_struct(a.keyID,b.keyID);jce_copy_struct(a.urlList,b.urlList);

#define jce_TVK_WatermarkNode_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.wmID,b.wmID);jce_copy_struct(a.x,b.x);jce_copy_struct(a.y,b.y);jce_copy_struct(a.w,b.w);jce_copy_struct(a.h,b.h);jce_copy_struct(a.a,b.a);jce_copy_struct(a.fileMD5,b.fileMD5);jce_copy_struct(a.url,b.url);

#define jce_TVK_PictureNode_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.flag,b.flag);jce_copy_struct(a.cd,b.cd);jce_copy_struct(a.h,b.h);jce_copy_struct(a.w,b.w);jce_copy_struct(a.r,b.r);jce_copy_struct(a.c,b.c);jce_copy_struct(a.urlList,b.urlList);

#define jce_TVK_SoftNode_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.formatID,b.formatID);jce_copy_struct(a.fileName,b.fileName);jce_copy_struct(a.urlList,b.urlList);jce_copy_struct(a.name,b.name);

#define jce_TVK_GetInfoRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.debug,b.debug);jce_copy_struct(a.user,b.user);jce_copy_struct(a.app,b.app);jce_copy_struct(a.video,b.video);

#define jce_TVK_GetInfoResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.debug,b.debug);jce_copy_struct(a.baseInfo,b.baseInfo);jce_copy_struct(a.vidNode,b.vidNode);jce_copy_struct(a.formatList,b.formatList);jce_copy_struct(a.urlList,b.urlList);jce_copy_struct(a.watermarkList,b.watermarkList);jce_copy_struct(a.pictureList,b.pictureList);jce_copy_struct(a.softList,b.softList);



#endif
