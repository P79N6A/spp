// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 3.1.1.2 by WSRD Tencent.
// Generated from `qqvideo_property.jce'
// **********************************************************************

#ifndef __QQVIDEO_PROPERTY_H_
#define __QQVIDEO_PROPERTY_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
using namespace std;
#include "qqvideo_common.h"


namespace jce
{
    struct PropertyItemData : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.PropertyItemData";
        }
        static string MD5()
        {
            return "c21e81f2197e8febacc89133f4b5ec10";
        }
        PropertyItemData()
        :propertyType(0),propertyName(""),propertyCount(0),propertyActivity(""),propertyUrl("")
        {
        }
        void resetDefautlt()
        {
            propertyType = 0;
            propertyName = "";
            propertyCount = 0;
            propertyActivity = "";
            propertyUrl = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(propertyType, 0);
            _os.write(propertyName, 1);
            _os.write(propertyCount, 2);
            _os.write(propertyActivity, 3);
            _os.write(propertyUrl, 4);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(propertyType, 0, true);
            _is.read(propertyName, 1, true);
            _is.read(propertyCount, 2, true);
            _is.read(propertyActivity, 3, false);
            _is.read(propertyUrl, 4, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(propertyType,"propertyType");
            _ds.display(propertyName,"propertyName");
            _ds.display(propertyCount,"propertyCount");
            _ds.display(propertyActivity,"propertyActivity");
            _ds.display(propertyUrl,"propertyUrl");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(propertyType, true);
            _ds.displaySimple(propertyName, true);
            _ds.displaySimple(propertyCount, true);
            _ds.displaySimple(propertyActivity, true);
            _ds.displaySimple(propertyUrl, false);
            return _os;
        }
    public:
        taf::Int32 propertyType;
        std::string propertyName;
        taf::Int64 propertyCount;
        std::string propertyActivity;
        std::string propertyUrl;
    };
    inline bool operator==(const PropertyItemData&l, const PropertyItemData&r)
    {
        return l.propertyType == r.propertyType && l.propertyName == r.propertyName && l.propertyCount == r.propertyCount && l.propertyActivity == r.propertyActivity && l.propertyUrl == r.propertyUrl;
    }
    inline bool operator!=(const PropertyItemData&l, const PropertyItemData&r)
    {
        return !(l == r);
    }

    struct DiamondBillItemData : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.DiamondBillItemData";
        }
        static string MD5()
        {
            return "0c1d945735360d4e3752e1b2d448ba0c";
        }
        DiamondBillItemData()
        :date(""),consumeDesc(""),consumeDescColor("")
        {
        }
        void resetDefautlt()
        {
            date = "";
            consumeDesc = "";
            consumeDescColor = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(date, 0);
            _os.write(consumeDesc, 1);
            _os.write(consumeDescColor, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(date, 0, true);
            _is.read(consumeDesc, 1, true);
            _is.read(consumeDescColor, 2, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(date,"date");
            _ds.display(consumeDesc,"consumeDesc");
            _ds.display(consumeDescColor,"consumeDescColor");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(date, true);
            _ds.displaySimple(consumeDesc, true);
            _ds.displaySimple(consumeDescColor, false);
            return _os;
        }
    public:
        std::string date;
        std::string consumeDesc;
        std::string consumeDescColor;
    };
    inline bool operator==(const DiamondBillItemData&l, const DiamondBillItemData&r)
    {
        return l.date == r.date && l.consumeDesc == r.consumeDesc && l.consumeDescColor == r.consumeDescColor;
    }
    inline bool operator!=(const DiamondBillItemData&l, const DiamondBillItemData&r)
    {
        return !(l == r);
    }

    struct DiamondConsumeItem : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.DiamondConsumeItem";
        }
        static string MD5()
        {
            return "2d54ee7ac8521c6a421ba4585104f484";
        }
        DiamondConsumeItem()
        :iapProductID(""),count(0),Description(""),price(0),imgUrl("")
        {
        }
        void resetDefautlt()
        {
            iapProductID = "";
            count = 0;
            Description = "";
            price = 0;
            imgUrl = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(iapProductID, 0);
            _os.write(count, 1);
            _os.write(Description, 2);
            _os.write(price, 3);
            _os.write(imgUrl, 4);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(iapProductID, 0, true);
            _is.read(count, 1, true);
            _is.read(Description, 2, true);
            _is.read(price, 3, true);
            _is.read(imgUrl, 4, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(iapProductID,"iapProductID");
            _ds.display(count,"count");
            _ds.display(Description,"Description");
            _ds.display(price,"price");
            _ds.display(imgUrl,"imgUrl");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(iapProductID, true);
            _ds.displaySimple(count, true);
            _ds.displaySimple(Description, true);
            _ds.displaySimple(price, true);
            _ds.displaySimple(imgUrl, false);
            return _os;
        }
    public:
        std::string iapProductID;
        taf::Int32 count;
        std::string Description;
        taf::Float price;
        std::string imgUrl;
    };
    inline bool operator==(const DiamondConsumeItem&l, const DiamondConsumeItem&r)
    {
        return l.iapProductID == r.iapProductID && l.count == r.count && l.Description == r.Description && l.price == r.price && l.imgUrl == r.imgUrl;
    }
    inline bool operator!=(const DiamondConsumeItem&l, const DiamondConsumeItem&r)
    {
        return !(l == r);
    }

    struct CoinConsumeItem : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.CoinConsumeItem";
        }
        static string MD5()
        {
            return "8b5307c15b590e3eb119e9572cc674c6";
        }
        CoinConsumeItem()
        :strActivityId(""),count(0),Description(""),price(0),imgUrl("")
        {
        }
        void resetDefautlt()
        {
            strActivityId = "";
            count = 0;
            Description = "";
            price = 0;
            imgUrl = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(strActivityId, 0);
            _os.write(count, 1);
            _os.write(Description, 2);
            _os.write(price, 3);
            _os.write(imgUrl, 4);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(strActivityId, 0, true);
            _is.read(count, 1, true);
            _is.read(Description, 2, true);
            _is.read(price, 3, true);
            _is.read(imgUrl, 4, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(strActivityId,"strActivityId");
            _ds.display(count,"count");
            _ds.display(Description,"Description");
            _ds.display(price,"price");
            _ds.display(imgUrl,"imgUrl");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(strActivityId, true);
            _ds.displaySimple(count, true);
            _ds.displaySimple(Description, true);
            _ds.displaySimple(price, true);
            _ds.displaySimple(imgUrl, false);
            return _os;
        }
    public:
        std::string strActivityId;
        taf::Int32 count;
        std::string Description;
        taf::Int32 price;
        std::string imgUrl;
    };
    inline bool operator==(const CoinConsumeItem&l, const CoinConsumeItem&r)
    {
        return l.strActivityId == r.strActivityId && l.count == r.count && l.Description == r.Description && l.price == r.price && l.imgUrl == r.imgUrl;
    }
    inline bool operator!=(const CoinConsumeItem&l, const CoinConsumeItem&r)
    {
        return !(l == r);
    }

    struct ProductItem : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.ProductItem";
        }
        static string MD5()
        {
            return "0d2ce2bfc4eeee1ad30063b5f17a7f57";
        }
        ProductItem()
        :strProductId(""),iProductNum(0)
        {
        }
        void resetDefautlt()
        {
            strProductId = "";
            iProductNum = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(strProductId, 0);
            _os.write(iProductNum, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(strProductId, 0, true);
            _is.read(iProductNum, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(strProductId,"strProductId");
            _ds.display(iProductNum,"iProductNum");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(strProductId, true);
            _ds.displaySimple(iProductNum, false);
            return _os;
        }
    public:
        std::string strProductId;
        taf::Int32 iProductNum;
    };
    inline bool operator==(const ProductItem&l, const ProductItem&r)
    {
        return l.strProductId == r.strProductId && l.iProductNum == r.iProductNum;
    }
    inline bool operator!=(const ProductItem&l, const ProductItem&r)
    {
        return !(l == r);
    }

    struct DiamondActivityRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.DiamondActivityRequest";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        DiamondActivityRequest()
        :optionalKey("")
        {
        }
        void resetDefautlt()
        {
            optionalKey = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(optionalKey, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(optionalKey, 0, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(optionalKey,"optionalKey");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(optionalKey, false);
            return _os;
        }
    public:
        std::string optionalKey;
    };
    inline bool operator==(const DiamondActivityRequest&l, const DiamondActivityRequest&r)
    {
        return l.optionalKey == r.optionalKey;
    }
    inline bool operator!=(const DiamondActivityRequest&l, const DiamondActivityRequest&r)
    {
        return !(l == r);
    }

    struct DiamondActivityResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.DiamondActivityResponse";
        }
        static string MD5()
        {
            return "26159cf77dcb9fe1c64b57dae580ccae";
        }
        DiamondActivityResponse()
        :errCode(0),activityDesc("")
        {
        }
        void resetDefautlt()
        {
            errCode = 0;
            activityDesc = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(errCode, 0);
            _os.write(activityDesc, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errCode, 0, true);
            _is.read(activityDesc, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(errCode,"errCode");
            _ds.display(activityDesc,"activityDesc");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(errCode, true);
            _ds.displaySimple(activityDesc, false);
            return _os;
        }
    public:
        taf::Int32 errCode;
        std::string activityDesc;
    };
    inline bool operator==(const DiamondActivityResponse&l, const DiamondActivityResponse&r)
    {
        return l.errCode == r.errCode && l.activityDesc == r.activityDesc;
    }
    inline bool operator!=(const DiamondActivityResponse&l, const DiamondActivityResponse&r)
    {
        return !(l == r);
    }

    struct PropertyMineRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.PropertyMineRequest";
        }
        static string MD5()
        {
            return "a0b289082212daccd07146ea9fd010bb";
        }
        PropertyMineRequest()
        :strPf(""),bCheckLogin(true)
        {
        }
        void resetDefautlt()
        {
            strPf = "";
            bCheckLogin = true;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(strPf, 0);
            _os.write(vecCoinType, 1);
            _os.write(bCheckLogin, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(strPf, 0, true);
            _is.read(vecCoinType, 1, true);
            _is.read(bCheckLogin, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(strPf,"strPf");
            _ds.display(vecCoinType,"vecCoinType");
            _ds.display(bCheckLogin,"bCheckLogin");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(strPf, true);
            _ds.displaySimple(vecCoinType, true);
            _ds.displaySimple(bCheckLogin, false);
            return _os;
        }
    public:
        std::string strPf;
        vector<taf::Int32> vecCoinType;
        taf::Bool bCheckLogin;
    };
    inline bool operator==(const PropertyMineRequest&l, const PropertyMineRequest&r)
    {
        return l.strPf == r.strPf && l.vecCoinType == r.vecCoinType && l.bCheckLogin == r.bCheckLogin;
    }
    inline bool operator!=(const PropertyMineRequest&l, const PropertyMineRequest&r)
    {
        return !(l == r);
    }

    struct PropertyMineResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.PropertyMineResponse";
        }
        static string MD5()
        {
            return "6ccf524022b206ef86a58de7fc9feac4";
        }
        PropertyMineResponse()
        :errCode(0),ts("")
        {
        }
        void resetDefautlt()
        {
            errCode = 0;
            ts = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(errCode, 0);
            _os.write(myProperty, 1);
            _os.write(ts, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errCode, 0, true);
            _is.read(myProperty, 1, true);
            _is.read(ts, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(errCode,"errCode");
            _ds.display(myProperty,"myProperty");
            _ds.display(ts,"ts");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(errCode, true);
            _ds.displaySimple(myProperty, true);
            _ds.displaySimple(ts, false);
            return _os;
        }
    public:
        taf::Int32 errCode;
        vector<jce::PropertyItemData> myProperty;
        std::string ts;
    };
    inline bool operator==(const PropertyMineResponse&l, const PropertyMineResponse&r)
    {
        return l.errCode == r.errCode && l.myProperty == r.myProperty && l.ts == r.ts;
    }
    inline bool operator!=(const PropertyMineResponse&l, const PropertyMineResponse&r)
    {
        return !(l == r);
    }

    struct DiamondBillRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.DiamondBillRequest";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        DiamondBillRequest()
        :pageContext("")
        {
        }
        void resetDefautlt()
        {
            pageContext = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(pageContext, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(pageContext, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(pageContext,"pageContext");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(pageContext, false);
            return _os;
        }
    public:
        std::string pageContext;
    };
    inline bool operator==(const DiamondBillRequest&l, const DiamondBillRequest&r)
    {
        return l.pageContext == r.pageContext;
    }
    inline bool operator!=(const DiamondBillRequest&l, const DiamondBillRequest&r)
    {
        return !(l == r);
    }

    struct DiamondBillResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.DiamondBillResponse";
        }
        static string MD5()
        {
            return "ced6bac41fa36fe9a6c876a7eaafec11";
        }
        DiamondBillResponse()
        :errCode(0),hasNextPage(true),pageContext("")
        {
        }
        void resetDefautlt()
        {
            errCode = 0;
            hasNextPage = true;
            pageContext = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(errCode, 0);
            _os.write(billList, 1);
            _os.write(hasNextPage, 2);
            _os.write(pageContext, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errCode, 0, true);
            _is.read(billList, 1, false);
            _is.read(hasNextPage, 2, true);
            _is.read(pageContext, 3, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(errCode,"errCode");
            _ds.display(billList,"billList");
            _ds.display(hasNextPage,"hasNextPage");
            _ds.display(pageContext,"pageContext");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(errCode, true);
            _ds.displaySimple(billList, true);
            _ds.displaySimple(hasNextPage, true);
            _ds.displaySimple(pageContext, false);
            return _os;
        }
    public:
        taf::Int32 errCode;
        vector<jce::DiamondBillItemData> billList;
        taf::Bool hasNextPage;
        std::string pageContext;
    };
    inline bool operator==(const DiamondBillResponse&l, const DiamondBillResponse&r)
    {
        return l.errCode == r.errCode && l.billList == r.billList && l.hasNextPage == r.hasNextPage && l.pageContext == r.pageContext;
    }
    inline bool operator!=(const DiamondBillResponse&l, const DiamondBillResponse&r)
    {
        return !(l == r);
    }

    struct PropertyPayRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.PropertyPayRequest";
        }
        static string MD5()
        {
            return "ebc51ae8b813776a0412ac6dd9b2472a";
        }
        PropertyPayRequest()
        :strPf(""),iSceneType(0),iSceneSubType(0),strActivityId(""),iProductType(0),strRef("")
        {
        }
        void resetDefautlt()
        {
            strPf = "";
            iSceneType = 0;
            iSceneSubType = 0;
            strActivityId = "";
            iProductType = 0;
            strRef = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(strPf, 0);
            _os.write(iSceneType, 1);
            _os.write(iSceneSubType, 2);
            _os.write(strActivityId, 3);
            _os.write(iProductType, 4);
            _os.write(vecProduct, 5);
            _os.write(strRef, 6);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(strPf, 0, true);
            _is.read(iSceneType, 1, true);
            _is.read(iSceneSubType, 2, true);
            _is.read(strActivityId, 3, true);
            _is.read(iProductType, 4, false);
            _is.read(vecProduct, 5, false);
            _is.read(strRef, 6, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(strPf,"strPf");
            _ds.display(iSceneType,"iSceneType");
            _ds.display(iSceneSubType,"iSceneSubType");
            _ds.display(strActivityId,"strActivityId");
            _ds.display(iProductType,"iProductType");
            _ds.display(vecProduct,"vecProduct");
            _ds.display(strRef,"strRef");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(strPf, true);
            _ds.displaySimple(iSceneType, true);
            _ds.displaySimple(iSceneSubType, true);
            _ds.displaySimple(strActivityId, true);
            _ds.displaySimple(iProductType, true);
            _ds.displaySimple(vecProduct, true);
            _ds.displaySimple(strRef, false);
            return _os;
        }
    public:
        std::string strPf;
        taf::Int32 iSceneType;
        taf::Int32 iSceneSubType;
        std::string strActivityId;
        taf::Int32 iProductType;
        vector<jce::ProductItem> vecProduct;
        std::string strRef;
    };
    inline bool operator==(const PropertyPayRequest&l, const PropertyPayRequest&r)
    {
        return l.strPf == r.strPf && l.iSceneType == r.iSceneType && l.iSceneSubType == r.iSceneSubType && l.strActivityId == r.strActivityId && l.iProductType == r.iProductType && l.vecProduct == r.vecProduct && l.strRef == r.strRef;
    }
    inline bool operator!=(const PropertyPayRequest&l, const PropertyPayRequest&r)
    {
        return !(l == r);
    }

    struct PropertyPayResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.PropertyPayResponse";
        }
        static string MD5()
        {
            return "1f47da24b69e655580a48d1f7cab279a";
        }
        PropertyPayResponse()
        :errCode(0),msg(""),billno("")
        {
        }
        void resetDefautlt()
        {
            errCode = 0;
            msg = "";
            billno = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(errCode, 0);
            _os.write(msg, 1);
            _os.write(billno, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errCode, 0, true);
            _is.read(msg, 1, true);
            _is.read(billno, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(errCode,"errCode");
            _ds.display(msg,"msg");
            _ds.display(billno,"billno");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(errCode, true);
            _ds.displaySimple(msg, true);
            _ds.displaySimple(billno, false);
            return _os;
        }
    public:
        taf::Int32 errCode;
        std::string msg;
        std::string billno;
    };
    inline bool operator==(const PropertyPayResponse&l, const PropertyPayResponse&r)
    {
        return l.errCode == r.errCode && l.msg == r.msg && l.billno == r.billno;
    }
    inline bool operator!=(const PropertyPayResponse&l, const PropertyPayResponse&r)
    {
        return !(l == r);
    }

    struct DiamondListRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.DiamondListRequest";
        }
        static string MD5()
        {
            return "05511bece4a2b65e1361cf6867461c97";
        }
        DiamondListRequest()
        :showType(0)
        {
        }
        void resetDefautlt()
        {
            showType = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(showType, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(showType, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(showType,"showType");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(showType, false);
            return _os;
        }
    public:
        taf::Int32 showType;
    };
    inline bool operator==(const DiamondListRequest&l, const DiamondListRequest&r)
    {
        return l.showType == r.showType;
    }
    inline bool operator!=(const DiamondListRequest&l, const DiamondListRequest&r)
    {
        return !(l == r);
    }

    struct DiamondListResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.DiamondListResponse";
        }
        static string MD5()
        {
            return "48ac952becb200208a2beb2fa9888963";
        }
        DiamondListResponse()
        :errCode(0),totLine(0),activityDesc("")
        {
        }
        void resetDefautlt()
        {
            errCode = 0;
            totLine = 0;
            activityDesc = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(errCode, 0);
            _os.write(totLine, 1);
            _os.write(diamondList, 2);
            _os.write(activityDesc, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errCode, 0, true);
            _is.read(totLine, 1, true);
            _is.read(diamondList, 2, true);
            _is.read(activityDesc, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(errCode,"errCode");
            _ds.display(totLine,"totLine");
            _ds.display(diamondList,"diamondList");
            _ds.display(activityDesc,"activityDesc");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(errCode, true);
            _ds.displaySimple(totLine, true);
            _ds.displaySimple(diamondList, true);
            _ds.displaySimple(activityDesc, false);
            return _os;
        }
    public:
        taf::Int32 errCode;
        taf::Int32 totLine;
        vector<jce::DiamondConsumeItem> diamondList;
        std::string activityDesc;
    };
    inline bool operator==(const DiamondListResponse&l, const DiamondListResponse&r)
    {
        return l.errCode == r.errCode && l.totLine == r.totLine && l.diamondList == r.diamondList && l.activityDesc == r.activityDesc;
    }
    inline bool operator!=(const DiamondListResponse&l, const DiamondListResponse&r)
    {
        return !(l == r);
    }

    struct CoinListRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.CoinListRequest";
        }
        static string MD5()
        {
            return "05511bece4a2b65e1361cf6867461c97";
        }
        CoinListRequest()
        :showType(0)
        {
        }
        void resetDefautlt()
        {
            showType = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(showType, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(showType, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(showType,"showType");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(showType, false);
            return _os;
        }
    public:
        taf::Int32 showType;
    };
    inline bool operator==(const CoinListRequest&l, const CoinListRequest&r)
    {
        return l.showType == r.showType;
    }
    inline bool operator!=(const CoinListRequest&l, const CoinListRequest&r)
    {
        return !(l == r);
    }

    struct CoinListResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.CoinListResponse";
        }
        static string MD5()
        {
            return "e854b4e86e05687d50bb48f8b4fd7d4e";
        }
        CoinListResponse()
        :errCode(0),totLine(0)
        {
        }
        void resetDefautlt()
        {
            errCode = 0;
            totLine = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(errCode, 0);
            _os.write(totLine, 1);
            _os.write(coinList, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errCode, 0, true);
            _is.read(totLine, 1, true);
            _is.read(coinList, 2, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(errCode,"errCode");
            _ds.display(totLine,"totLine");
            _ds.display(coinList,"coinList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(errCode, true);
            _ds.displaySimple(totLine, true);
            _ds.displaySimple(coinList, false);
            return _os;
        }
    public:
        taf::Int32 errCode;
        taf::Int32 totLine;
        vector<jce::CoinConsumeItem> coinList;
    };
    inline bool operator==(const CoinListResponse&l, const CoinListResponse&r)
    {
        return l.errCode == r.errCode && l.totLine == r.totLine && l.coinList == r.coinList;
    }
    inline bool operator!=(const CoinListResponse&l, const CoinListResponse&r)
    {
        return !(l == r);
    }

    struct TransPropertyRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.TransPropertyRequest";
        }
        static string MD5()
        {
            return "00443dd6685367b21bac154927b1b5b6";
        }
        TransPropertyRequest()
        :tk(""),ts(""),strPf(""),iSceneType(0),iSceneSubType(0)
        {
        }
        void resetDefautlt()
        {
            tk = "";
            ts = "";
            strPf = "";
            iSceneType = 0;
            iSceneSubType = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(tk, 0);
            _os.write(ts, 1);
            _os.write(vecCoinType, 2);
            _os.write(strPf, 3);
            _os.write(iSceneType, 4);
            _os.write(iSceneSubType, 5);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(tk, 0, true);
            _is.read(ts, 1, true);
            _is.read(vecCoinType, 2, true);
            _is.read(strPf, 3, true);
            _is.read(iSceneType, 4, true);
            _is.read(iSceneSubType, 5, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(tk,"tk");
            _ds.display(ts,"ts");
            _ds.display(vecCoinType,"vecCoinType");
            _ds.display(strPf,"strPf");
            _ds.display(iSceneType,"iSceneType");
            _ds.display(iSceneSubType,"iSceneSubType");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(tk, true);
            _ds.displaySimple(ts, true);
            _ds.displaySimple(vecCoinType, true);
            _ds.displaySimple(strPf, true);
            _ds.displaySimple(iSceneType, true);
            _ds.displaySimple(iSceneSubType, false);
            return _os;
        }
    public:
        std::string tk;
        std::string ts;
        vector<taf::Int32> vecCoinType;
        std::string strPf;
        taf::Int32 iSceneType;
        taf::Int32 iSceneSubType;
    };
    inline bool operator==(const TransPropertyRequest&l, const TransPropertyRequest&r)
    {
        return l.tk == r.tk && l.ts == r.ts && l.vecCoinType == r.vecCoinType && l.strPf == r.strPf && l.iSceneType == r.iSceneType && l.iSceneSubType == r.iSceneSubType;
    }
    inline bool operator!=(const TransPropertyRequest&l, const TransPropertyRequest&r)
    {
        return !(l == r);
    }

    struct TransPropertyResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.TransPropertyResponse";
        }
        static string MD5()
        {
            return "26159cf77dcb9fe1c64b57dae580ccae";
        }
        TransPropertyResponse()
        :errCode(0),msg("")
        {
        }
        void resetDefautlt()
        {
            errCode = 0;
            msg = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(errCode, 0);
            _os.write(msg, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errCode, 0, true);
            _is.read(msg, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(errCode,"errCode");
            _ds.display(msg,"msg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(errCode, true);
            _ds.displaySimple(msg, false);
            return _os;
        }
    public:
        taf::Int32 errCode;
        std::string msg;
    };
    inline bool operator==(const TransPropertyResponse&l, const TransPropertyResponse&r)
    {
        return l.errCode == r.errCode && l.msg == r.msg;
    }
    inline bool operator!=(const TransPropertyResponse&l, const TransPropertyResponse&r)
    {
        return !(l == r);
    }

    struct ActPopItemData : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.ActPopItemData";
        }
        static string MD5()
        {
            return "c73c13678f156f762d622e8672930c1d";
        }
        ActPopItemData()
        :strShowTxt(""),strLeftTxt(""),strRightTxt(""),strActivityId(""),strImageUrl("")
        {
        }
        void resetDefautlt()
        {
            strShowTxt = "";
            strLeftTxt = "";
            strRightTxt = "";
            strActivityId = "";
            strImageUrl = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(strShowTxt, 0);
            _os.write(strLeftTxt, 1);
            _os.write(strRightTxt, 2);
            _os.write(strActivityId, 3);
            _os.write(strImageUrl, 4);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(strShowTxt, 0, false);
            _is.read(strLeftTxt, 1, false);
            _is.read(strRightTxt, 2, false);
            _is.read(strActivityId, 3, false);
            _is.read(strImageUrl, 4, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(strShowTxt,"strShowTxt");
            _ds.display(strLeftTxt,"strLeftTxt");
            _ds.display(strRightTxt,"strRightTxt");
            _ds.display(strActivityId,"strActivityId");
            _ds.display(strImageUrl,"strImageUrl");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(strShowTxt, true);
            _ds.displaySimple(strLeftTxt, true);
            _ds.displaySimple(strRightTxt, true);
            _ds.displaySimple(strActivityId, true);
            _ds.displaySimple(strImageUrl, false);
            return _os;
        }
    public:
        std::string strShowTxt;
        std::string strLeftTxt;
        std::string strRightTxt;
        std::string strActivityId;
        std::string strImageUrl;
    };
    inline bool operator==(const ActPopItemData&l, const ActPopItemData&r)
    {
        return l.strShowTxt == r.strShowTxt && l.strLeftTxt == r.strLeftTxt && l.strRightTxt == r.strRightTxt && l.strActivityId == r.strActivityId && l.strImageUrl == r.strImageUrl;
    }
    inline bool operator!=(const ActPopItemData&l, const ActPopItemData&r)
    {
        return !(l == r);
    }

    struct ActPopRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.ActPopRequest";
        }
        static string MD5()
        {
            return "309782aed2f570cb74841a7d410ade2f";
        }
        ActPopRequest()
        :iSenceId(0),lLastShowTime(0)
        {
        }
        void resetDefautlt()
        {
            iSenceId = 0;
            lLastShowTime = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(iSenceId, 0);
            _os.write(lLastShowTime, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(iSenceId, 0, true);
            _is.read(lLastShowTime, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(iSenceId,"iSenceId");
            _ds.display(lLastShowTime,"lLastShowTime");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(iSenceId, true);
            _ds.displaySimple(lLastShowTime, false);
            return _os;
        }
    public:
        taf::Int32 iSenceId;
        taf::Int64 lLastShowTime;
    };
    inline bool operator==(const ActPopRequest&l, const ActPopRequest&r)
    {
        return l.iSenceId == r.iSenceId && l.lLastShowTime == r.lLastShowTime;
    }
    inline bool operator!=(const ActPopRequest&l, const ActPopRequest&r)
    {
        return !(l == r);
    }

    struct ActPopResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.ActPopResponse";
        }
        static string MD5()
        {
            return "cd8d41958a66f0513ce5d58026c5371d";
        }
        ActPopResponse()
        :errCode(0),bShow(true),lShowTime(0),sEffectUrl(""),sSuccessTxt(""),sFailTxt("")
        {
        }
        void resetDefautlt()
        {
            errCode = 0;
            bShow = true;
            lShowTime = 0;
            sEffectUrl = "";
            sSuccessTxt = "";
            sFailTxt = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(errCode, 0);
            _os.write(bShow, 1);
            _os.write(oPopData, 2);
            _os.write(lShowTime, 3);
            _os.write(sEffectUrl, 4);
            _os.write(sSuccessTxt, 5);
            _os.write(sFailTxt, 6);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errCode, 0, true);
            _is.read(bShow, 1, true);
            _is.read(oPopData, 2, false);
            _is.read(lShowTime, 3, false);
            _is.read(sEffectUrl, 4, false);
            _is.read(sSuccessTxt, 5, false);
            _is.read(sFailTxt, 6, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(errCode,"errCode");
            _ds.display(bShow,"bShow");
            _ds.display(oPopData,"oPopData");
            _ds.display(lShowTime,"lShowTime");
            _ds.display(sEffectUrl,"sEffectUrl");
            _ds.display(sSuccessTxt,"sSuccessTxt");
            _ds.display(sFailTxt,"sFailTxt");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(errCode, true);
            _ds.displaySimple(bShow, true);
            _ds.displaySimple(oPopData, true);
            _ds.displaySimple(lShowTime, true);
            _ds.displaySimple(sEffectUrl, true);
            _ds.displaySimple(sSuccessTxt, true);
            _ds.displaySimple(sFailTxt, false);
            return _os;
        }
    public:
        taf::Int32 errCode;
        taf::Bool bShow;
        jce::ActPopItemData oPopData;
        taf::Int64 lShowTime;
        std::string sEffectUrl;
        std::string sSuccessTxt;
        std::string sFailTxt;
    };
    inline bool operator==(const ActPopResponse&l, const ActPopResponse&r)
    {
        return l.errCode == r.errCode && l.bShow == r.bShow && l.oPopData == r.oPopData && l.lShowTime == r.lShowTime && l.sEffectUrl == r.sEffectUrl && l.sSuccessTxt == r.sSuccessTxt && l.sFailTxt == r.sFailTxt;
    }
    inline bool operator!=(const ActPopResponse&l, const ActPopResponse&r)
    {
        return !(l == r);
    }

    struct GiftNode : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.GiftNode";
        }
        static string MD5()
        {
            return "4bca472ee0b6be681172ede156cc01f2";
        }
        GiftNode()
        :id(""),num(0),givetime(0)
        {
        }
        void resetDefautlt()
        {
            id = "";
            num = 0;
            givetime = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(id, 0);
            _os.write(num, 1);
            _os.write(info, 2);
            _os.write(givetime, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(id, 0, true);
            _is.read(num, 1, true);
            _is.read(info, 2, false);
            _is.read(givetime, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(id,"id");
            _ds.display(num,"num");
            _ds.display(info,"info");
            _ds.display(givetime,"givetime");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(id, true);
            _ds.displaySimple(num, true);
            _ds.displaySimple(info, true);
            _ds.displaySimple(givetime, false);
            return _os;
        }
    public:
        std::string id;
        taf::Int32 num;
        jce::LiveGiftItem info;
        taf::Int32 givetime;
    };
    inline bool operator==(const GiftNode&l, const GiftNode&r)
    {
        return l.id == r.id && l.num == r.num && l.info == r.info && l.givetime == r.givetime;
    }
    inline bool operator!=(const GiftNode&l, const GiftNode&r)
    {
        return !(l == r);
    }

    struct GiftPolicyRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.GiftPolicyRequest";
        }
        static string MD5()
        {
            return "acea8fd29f9905984891746d10f3f73a";
        }
        GiftPolicyRequest()
        :sceneKey(""),keytype(0),id(""),curTimeStamp(0)
        {
        }
        void resetDefautlt()
        {
            sceneKey = "";
            keytype = 0;
            id = "";
            curTimeStamp = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(sceneKey, 0);
            _os.write(keytype, 1);
            _os.write(id, 2);
            _os.write(curTimeStamp, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(sceneKey, 0, true);
            _is.read(keytype, 1, true);
            _is.read(id, 2, true);
            _is.read(curTimeStamp, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(sceneKey,"sceneKey");
            _ds.display(keytype,"keytype");
            _ds.display(id,"id");
            _ds.display(curTimeStamp,"curTimeStamp");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(sceneKey, true);
            _ds.displaySimple(keytype, true);
            _ds.displaySimple(id, true);
            _ds.displaySimple(curTimeStamp, false);
            return _os;
        }
    public:
        std::string sceneKey;
        taf::Int32 keytype;
        std::string id;
        taf::Int64 curTimeStamp;
    };
    inline bool operator==(const GiftPolicyRequest&l, const GiftPolicyRequest&r)
    {
        return l.sceneKey == r.sceneKey && l.keytype == r.keytype && l.id == r.id && l.curTimeStamp == r.curTimeStamp;
    }
    inline bool operator!=(const GiftPolicyRequest&l, const GiftPolicyRequest&r)
    {
        return !(l == r);
    }

    struct GiftPolicyResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.GiftPolicyResponse";
        }
        static string MD5()
        {
            return "7ac6723b0a69a1de7c436c7abf95f2ed";
        }
        GiftPolicyResponse()
        :retcode(0)
        {
        }
        void resetDefautlt()
        {
            retcode = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(retcode, 0);
            _os.write(policyList, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(retcode, 0, true);
            _is.read(policyList, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(retcode,"retcode");
            _ds.display(policyList,"policyList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(retcode, true);
            _ds.displaySimple(policyList, false);
            return _os;
        }
    public:
        taf::Int32 retcode;
        vector<jce::GiftNode> policyList;
    };
    inline bool operator==(const GiftPolicyResponse&l, const GiftPolicyResponse&r)
    {
        return l.retcode == r.retcode && l.policyList == r.policyList;
    }
    inline bool operator!=(const GiftPolicyResponse&l, const GiftPolicyResponse&r)
    {
        return !(l == r);
    }

    struct GiftPresentRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.GiftPresentRequest";
        }
        static string MD5()
        {
            return "23b1a891324cc1331ae51f3d93fa6e84";
        }
        GiftPresentRequest()
        :sceneKey(""),keytype(0),id(""),type(0),flag(0)
        {
        }
        void resetDefautlt()
        {
            sceneKey = "";
            keytype = 0;
            id = "";
            type = 0;
            flag = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(sceneKey, 0);
            _os.write(keytype, 1);
            _os.write(id, 2);
            _os.write(type, 3);
            _os.write(gift, 4);
            _os.write(flag, 5);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(sceneKey, 0, true);
            _is.read(keytype, 1, true);
            _is.read(id, 2, true);
            _is.read(type, 3, true);
            _is.read(gift, 4, true);
            _is.read(flag, 5, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(sceneKey,"sceneKey");
            _ds.display(keytype,"keytype");
            _ds.display(id,"id");
            _ds.display(type,"type");
            _ds.display(gift,"gift");
            _ds.display(flag,"flag");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(sceneKey, true);
            _ds.displaySimple(keytype, true);
            _ds.displaySimple(id, true);
            _ds.displaySimple(type, true);
            _ds.displaySimple(gift, true);
            _ds.displaySimple(flag, false);
            return _os;
        }
    public:
        std::string sceneKey;
        taf::Int32 keytype;
        std::string id;
        taf::Int32 type;
        jce::GiftNode gift;
        taf::Int64 flag;
    };
    inline bool operator==(const GiftPresentRequest&l, const GiftPresentRequest&r)
    {
        return l.sceneKey == r.sceneKey && l.keytype == r.keytype && l.id == r.id && l.type == r.type && l.gift == r.gift && l.flag == r.flag;
    }
    inline bool operator!=(const GiftPresentRequest&l, const GiftPresentRequest&r)
    {
        return !(l == r);
    }

    struct GiftPresentResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.GiftPresentResponse";
        }
        static string MD5()
        {
            return "32538c279b41b18edc2d73e04e30e0e7";
        }
        GiftPresentResponse()
        :retcode(0),flag(0)
        {
        }
        void resetDefautlt()
        {
            retcode = 0;
            flag = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(retcode, 0);
            _os.write(gift, 1);
            _os.write(flag, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(retcode, 0, true);
            _is.read(gift, 1, true);
            _is.read(flag, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(retcode,"retcode");
            _ds.display(gift,"gift");
            _ds.display(flag,"flag");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(retcode, true);
            _ds.displaySimple(gift, true);
            _ds.displaySimple(flag, false);
            return _os;
        }
    public:
        taf::Int32 retcode;
        jce::GiftNode gift;
        taf::Int64 flag;
    };
    inline bool operator==(const GiftPresentResponse&l, const GiftPresentResponse&r)
    {
        return l.retcode == r.retcode && l.gift == r.gift && l.flag == r.flag;
    }
    inline bool operator!=(const GiftPresentResponse&l, const GiftPresentResponse&r)
    {
        return !(l == r);
    }

    struct PropertyPayAndApplyRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.PropertyPayAndApplyRequest";
        }
        static string MD5()
        {
            return "349e719b3f689f7edcae3879e4fd7e4d";
        }
        PropertyPayAndApplyRequest()
        :propsDataKey(""),requestType(0),productId(""),productNum(0),idType(0),actorId(""),model(0),productType(0),overRank(0)
        {
        }
        void resetDefautlt()
        {
            propsDataKey = "";
            requestType = 0;
            productId = "";
            productNum = 0;
            idType = 0;
            actorId = "";
            model = 0;
            productType = 0;
            overRank = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(propsDataKey, 0);
            _os.write(requestType, 1);
            _os.write(productId, 2);
            _os.write(productNum, 3);
            _os.write(idType, 4);
            _os.write(actorId, 5);
            _os.write(model, 6);
            _os.write(productType, 7);
            _os.write(overRank, 8);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(propsDataKey, 0, true);
            _is.read(requestType, 1, true);
            _is.read(productId, 2, true);
            _is.read(productNum, 3, true);
            _is.read(idType, 4, true);
            _is.read(actorId, 5, true);
            _is.read(model, 6, false);
            _is.read(productType, 7, false);
            _is.read(overRank, 8, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(propsDataKey,"propsDataKey");
            _ds.display(requestType,"requestType");
            _ds.display(productId,"productId");
            _ds.display(productNum,"productNum");
            _ds.display(idType,"idType");
            _ds.display(actorId,"actorId");
            _ds.display(model,"model");
            _ds.display(productType,"productType");
            _ds.display(overRank,"overRank");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(propsDataKey, true);
            _ds.displaySimple(requestType, true);
            _ds.displaySimple(productId, true);
            _ds.displaySimple(productNum, true);
            _ds.displaySimple(idType, true);
            _ds.displaySimple(actorId, true);
            _ds.displaySimple(model, true);
            _ds.displaySimple(productType, true);
            _ds.displaySimple(overRank, false);
            return _os;
        }
    public:
        std::string propsDataKey;
        taf::Int32 requestType;
        std::string productId;
        taf::Int64 productNum;
        taf::Int32 idType;
        std::string actorId;
        taf::Int32 model;
        taf::Int32 productType;
        taf::Int32 overRank;
    };
    inline bool operator==(const PropertyPayAndApplyRequest&l, const PropertyPayAndApplyRequest&r)
    {
        return l.propsDataKey == r.propsDataKey && l.requestType == r.requestType && l.productId == r.productId && l.productNum == r.productNum && l.idType == r.idType && l.actorId == r.actorId && l.model == r.model && l.productType == r.productType && l.overRank == r.overRank;
    }
    inline bool operator!=(const PropertyPayAndApplyRequest&l, const PropertyPayAndApplyRequest&r)
    {
        return !(l == r);
    }

    struct PropertyPayAndApplyResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.PropertyPayAndApplyResponse";
        }
        static string MD5()
        {
            return "7d558c4023f437285a566f67f2a0c1a4";
        }
        PropertyPayAndApplyResponse()
        :errCode(0),msg(""),productType(0),rank(0)
        {
        }
        void resetDefautlt()
        {
            errCode = 0;
            msg = "";
            productType = 0;
            rank = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(errCode, 0);
            _os.write(msg, 1);
            _os.write(giftItem, 2);
            _os.write(productType, 3);
            _os.write(rank, 4);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errCode, 0, true);
            _is.read(msg, 1, false);
            _is.read(giftItem, 2, false);
            _is.read(productType, 3, false);
            _is.read(rank, 4, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(errCode,"errCode");
            _ds.display(msg,"msg");
            _ds.display(giftItem,"giftItem");
            _ds.display(productType,"productType");
            _ds.display(rank,"rank");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(errCode, true);
            _ds.displaySimple(msg, true);
            _ds.displaySimple(giftItem, true);
            _ds.displaySimple(productType, true);
            _ds.displaySimple(rank, false);
            return _os;
        }
    public:
        taf::Int32 errCode;
        std::string msg;
        jce::LiveGiftItem giftItem;
        taf::Int32 productType;
        taf::Int64 rank;
    };
    inline bool operator==(const PropertyPayAndApplyResponse&l, const PropertyPayAndApplyResponse&r)
    {
        return l.errCode == r.errCode && l.msg == r.msg && l.giftItem == r.giftItem && l.productType == r.productType && l.rank == r.rank;
    }
    inline bool operator!=(const PropertyPayAndApplyResponse&l, const PropertyPayAndApplyResponse&r)
    {
        return !(l == r);
    }


}

#define jce_PropertyItemData_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.propertyType,b.propertyType);jce_copy_struct(a.propertyName,b.propertyName);jce_copy_struct(a.propertyCount,b.propertyCount);jce_copy_struct(a.propertyActivity,b.propertyActivity);jce_copy_struct(a.propertyUrl,b.propertyUrl);

#define jce_DiamondBillItemData_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.date,b.date);jce_copy_struct(a.consumeDesc,b.consumeDesc);jce_copy_struct(a.consumeDescColor,b.consumeDescColor);

#define jce_DiamondConsumeItem_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.iapProductID,b.iapProductID);jce_copy_struct(a.count,b.count);jce_copy_struct(a.Description,b.Description);jce_copy_struct(a.price,b.price);jce_copy_struct(a.imgUrl,b.imgUrl);

#define jce_CoinConsumeItem_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.strActivityId,b.strActivityId);jce_copy_struct(a.count,b.count);jce_copy_struct(a.Description,b.Description);jce_copy_struct(a.price,b.price);jce_copy_struct(a.imgUrl,b.imgUrl);

#define jce_ProductItem_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.strProductId,b.strProductId);jce_copy_struct(a.iProductNum,b.iProductNum);

#define jce_DiamondActivityRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.optionalKey,b.optionalKey);

#define jce_DiamondActivityResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.errCode,b.errCode);jce_copy_struct(a.activityDesc,b.activityDesc);

#define jce_PropertyMineRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.strPf,b.strPf);jce_copy_struct(a.vecCoinType,b.vecCoinType);jce_copy_struct(a.bCheckLogin,b.bCheckLogin);

#define jce_PropertyMineResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.errCode,b.errCode);jce_copy_struct(a.myProperty,b.myProperty);jce_copy_struct(a.ts,b.ts);

#define jce_DiamondBillRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.pageContext,b.pageContext);

#define jce_DiamondBillResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.errCode,b.errCode);jce_copy_struct(a.billList,b.billList);jce_copy_struct(a.hasNextPage,b.hasNextPage);jce_copy_struct(a.pageContext,b.pageContext);

#define jce_PropertyPayRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.strPf,b.strPf);jce_copy_struct(a.iSceneType,b.iSceneType);jce_copy_struct(a.iSceneSubType,b.iSceneSubType);jce_copy_struct(a.strActivityId,b.strActivityId);jce_copy_struct(a.iProductType,b.iProductType);jce_copy_struct(a.vecProduct,b.vecProduct);jce_copy_struct(a.strRef,b.strRef);

#define jce_PropertyPayResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.errCode,b.errCode);jce_copy_struct(a.msg,b.msg);jce_copy_struct(a.billno,b.billno);

#define jce_DiamondListRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.showType,b.showType);

#define jce_DiamondListResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.errCode,b.errCode);jce_copy_struct(a.totLine,b.totLine);jce_copy_struct(a.diamondList,b.diamondList);jce_copy_struct(a.activityDesc,b.activityDesc);

#define jce_CoinListRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.showType,b.showType);

#define jce_CoinListResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.errCode,b.errCode);jce_copy_struct(a.totLine,b.totLine);jce_copy_struct(a.coinList,b.coinList);

#define jce_TransPropertyRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.tk,b.tk);jce_copy_struct(a.ts,b.ts);jce_copy_struct(a.vecCoinType,b.vecCoinType);jce_copy_struct(a.strPf,b.strPf);jce_copy_struct(a.iSceneType,b.iSceneType);jce_copy_struct(a.iSceneSubType,b.iSceneSubType);

#define jce_TransPropertyResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.errCode,b.errCode);jce_copy_struct(a.msg,b.msg);

#define jce_ActPopItemData_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.strShowTxt,b.strShowTxt);jce_copy_struct(a.strLeftTxt,b.strLeftTxt);jce_copy_struct(a.strRightTxt,b.strRightTxt);jce_copy_struct(a.strActivityId,b.strActivityId);jce_copy_struct(a.strImageUrl,b.strImageUrl);

#define jce_ActPopRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.iSenceId,b.iSenceId);jce_copy_struct(a.lLastShowTime,b.lLastShowTime);

#define jce_ActPopResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.errCode,b.errCode);jce_copy_struct(a.bShow,b.bShow);jce_copy_struct(a.oPopData,b.oPopData);jce_copy_struct(a.lShowTime,b.lShowTime);jce_copy_struct(a.sEffectUrl,b.sEffectUrl);jce_copy_struct(a.sSuccessTxt,b.sSuccessTxt);jce_copy_struct(a.sFailTxt,b.sFailTxt);

#define jce_GiftNode_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.id,b.id);jce_copy_struct(a.num,b.num);jce_copy_struct(a.info,b.info);jce_copy_struct(a.givetime,b.givetime);

#define jce_GiftPolicyRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.sceneKey,b.sceneKey);jce_copy_struct(a.keytype,b.keytype);jce_copy_struct(a.id,b.id);jce_copy_struct(a.curTimeStamp,b.curTimeStamp);

#define jce_GiftPolicyResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.retcode,b.retcode);jce_copy_struct(a.policyList,b.policyList);

#define jce_GiftPresentRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.sceneKey,b.sceneKey);jce_copy_struct(a.keytype,b.keytype);jce_copy_struct(a.id,b.id);jce_copy_struct(a.type,b.type);jce_copy_struct(a.gift,b.gift);jce_copy_struct(a.flag,b.flag);

#define jce_GiftPresentResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.retcode,b.retcode);jce_copy_struct(a.gift,b.gift);jce_copy_struct(a.flag,b.flag);

#define jce_PropertyPayAndApplyRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.propsDataKey,b.propsDataKey);jce_copy_struct(a.requestType,b.requestType);jce_copy_struct(a.productId,b.productId);jce_copy_struct(a.productNum,b.productNum);jce_copy_struct(a.idType,b.idType);jce_copy_struct(a.actorId,b.actorId);jce_copy_struct(a.model,b.model);jce_copy_struct(a.productType,b.productType);jce_copy_struct(a.overRank,b.overRank);

#define jce_PropertyPayAndApplyResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.errCode,b.errCode);jce_copy_struct(a.msg,b.msg);jce_copy_struct(a.giftItem,b.giftItem);jce_copy_struct(a.productType,b.productType);jce_copy_struct(a.rank,b.rank);



#endif
