// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 3.1.1.2 by WSRD Tencent.
// Generated from `qqvideo_video.jce'
// **********************************************************************

#ifndef __QQVIDEO_VIDEO_H_
#define __QQVIDEO_VIDEO_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
using namespace std;


namespace jce
{
    struct VideoPlayInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.VideoPlayInfo";
        }
        static string MD5()
        {
            return "305c45774ae58dd9efba37af5c1840bb";
        }
        VideoPlayInfo()
        :defn(""),dtype(0),otype(""),callback(""),callvar(""),ptime(0),clip(0),dlna(0),fhdswitch(0),charge(0),defsrc(0)
        {
        }
        void resetDefautlt()
        {
            defn = "";
            dtype = 0;
            otype = "";
            callback = "";
            callvar = "";
            ptime = 0;
            clip = 0;
            dlna = 0;
            fhdswitch = 0;
            charge = 0;
            defsrc = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(vids, 0);
            _os.write(defn, 1);
            _os.write(dtype, 2);
            _os.write(otype, 3);
            _os.write(callback, 4);
            _os.write(callvar, 5);
            _os.write(ptime, 6);
            _os.write(clip, 7);
            _os.write(dlna, 8);
            _os.write(fhdswitch, 9);
            _os.write(charge, 10);
            _os.write(defsrc, 11);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(vids, 0, true);
            _is.read(defn, 1, false);
            _is.read(dtype, 2, false);
            _is.read(otype, 3, false);
            _is.read(callback, 4, false);
            _is.read(callvar, 5, false);
            _is.read(ptime, 6, false);
            _is.read(clip, 7, false);
            _is.read(dlna, 8, false);
            _is.read(fhdswitch, 9, false);
            _is.read(charge, 10, false);
            _is.read(defsrc, 11, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(vids,"vids");
            _ds.display(defn,"defn");
            _ds.display(dtype,"dtype");
            _ds.display(otype,"otype");
            _ds.display(callback,"callback");
            _ds.display(callvar,"callvar");
            _ds.display(ptime,"ptime");
            _ds.display(clip,"clip");
            _ds.display(dlna,"dlna");
            _ds.display(fhdswitch,"fhdswitch");
            _ds.display(charge,"charge");
            _ds.display(defsrc,"defsrc");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(vids, true);
            _ds.displaySimple(defn, true);
            _ds.displaySimple(dtype, true);
            _ds.displaySimple(otype, true);
            _ds.displaySimple(callback, true);
            _ds.displaySimple(callvar, true);
            _ds.displaySimple(ptime, true);
            _ds.displaySimple(clip, true);
            _ds.displaySimple(dlna, true);
            _ds.displaySimple(fhdswitch, true);
            _ds.displaySimple(charge, true);
            _ds.displaySimple(defsrc, false);
            return _os;
        }
    public:
        vector<std::string> vids;
        std::string defn;
        taf::Int32 dtype;
        std::string otype;
        std::string callback;
        std::string callvar;
        taf::Int32 ptime;
        taf::Int32 clip;
        taf::Int32 dlna;
        taf::Int32 fhdswitch;
        taf::Int32 charge;
        taf::Int32 defsrc;
    };
    inline bool operator==(const VideoPlayInfo&l, const VideoPlayInfo&r)
    {
        return l.vids == r.vids && l.defn == r.defn && l.dtype == r.dtype && l.otype == r.otype && l.callback == r.callback && l.callvar == r.callvar && l.ptime == r.ptime && l.clip == r.clip && l.dlna == r.dlna && l.fhdswitch == r.fhdswitch && l.charge == r.charge && l.defsrc == r.defsrc;
    }
    inline bool operator!=(const VideoPlayInfo&l, const VideoPlayInfo&r)
    {
        return !(l == r);
    }

    struct VideoAppInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.VideoAppInfo";
        }
        static string MD5()
        {
            return "fd7851a97a3a900e29647adf3b600c0c";
        }
        VideoAppInfo()
        :platform(0),device(0),hevclv(0),sdtfrom(""),randnum(0),encryptver(""),incver(0),fp2p(0),defnpayver(0),sphls(0),sphttps(0),spdrm(0)
        {
        }
        void resetDefautlt()
        {
            platform = 0;
            device = 0;
            hevclv = 0;
            sdtfrom = "";
            randnum = 0;
            encryptver = "";
            incver = 0;
            fp2p = 0;
            defnpayver = 0;
            sphls = 0;
            sphttps = 0;
            spdrm = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(platform, 0);
            _os.write(device, 1);
            _os.write(hevclv, 2);
            _os.write(sdtfrom, 3);
            _os.write(randnum, 4);
            _os.write(encryptver, 5);
            _os.write(incver, 6);
            _os.write(fp2p, 7);
            _os.write(defnpayver, 8);
            _os.write(sphls, 9);
            _os.write(sphttps, 10);
            _os.write(spdrm, 11);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(platform, 0, true);
            _is.read(device, 1, false);
            _is.read(hevclv, 2, false);
            _is.read(sdtfrom, 3, false);
            _is.read(randnum, 4, false);
            _is.read(encryptver, 5, false);
            _is.read(incver, 6, false);
            _is.read(fp2p, 7, false);
            _is.read(defnpayver, 8, false);
            _is.read(sphls, 9, false);
            _is.read(sphttps, 10, false);
            _is.read(spdrm, 11, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(platform,"platform");
            _ds.display(device,"device");
            _ds.display(hevclv,"hevclv");
            _ds.display(sdtfrom,"sdtfrom");
            _ds.display(randnum,"randnum");
            _ds.display(encryptver,"encryptver");
            _ds.display(incver,"incver");
            _ds.display(fp2p,"fp2p");
            _ds.display(defnpayver,"defnpayver");
            _ds.display(sphls,"sphls");
            _ds.display(sphttps,"sphttps");
            _ds.display(spdrm,"spdrm");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(platform, true);
            _ds.displaySimple(device, true);
            _ds.displaySimple(hevclv, true);
            _ds.displaySimple(sdtfrom, true);
            _ds.displaySimple(randnum, true);
            _ds.displaySimple(encryptver, true);
            _ds.displaySimple(incver, true);
            _ds.displaySimple(fp2p, true);
            _ds.displaySimple(defnpayver, true);
            _ds.displaySimple(sphls, true);
            _ds.displaySimple(sphttps, true);
            _ds.displaySimple(spdrm, false);
            return _os;
        }
    public:
        taf::Int64 platform;
        taf::Int32 device;
        taf::Int32 hevclv;
        std::string sdtfrom;
        taf::Int64 randnum;
        std::string encryptver;
        taf::Int32 incver;
        taf::Int32 fp2p;
        taf::Int32 defnpayver;
        taf::Int32 sphls;
        taf::Int32 sphttps;
        taf::Int32 spdrm;
    };
    inline bool operator==(const VideoAppInfo&l, const VideoAppInfo&r)
    {
        return l.platform == r.platform && l.device == r.device && l.hevclv == r.hevclv && l.sdtfrom == r.sdtfrom && l.randnum == r.randnum && l.encryptver == r.encryptver && l.incver == r.incver && l.fp2p == r.fp2p && l.defnpayver == r.defnpayver && l.sphls == r.sphls && l.sphttps == r.sphttps && l.spdrm == r.spdrm;
    }
    inline bool operator!=(const VideoAppInfo&l, const VideoAppInfo&r)
    {
        return !(l == r);
    }

    struct VideoUserInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.VideoUserInfo";
        }
        static string MD5()
        {
            return "0ce4ad79699a6eb6c79f1f952fe64bf3";
        }
        VideoUserInfo()
        :ckey(""),nettype(0),speed(0),speeds(""),telcom(""),unicom(""),unicomtype(-1)
        {
        }
        void resetDefautlt()
        {
            ckey = "";
            nettype = 0;
            speed = 0;
            speeds = "";
            telcom = "";
            unicom = "";
            unicomtype = -1;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(ckey, 0);
            _os.write(nettype, 1);
            _os.write(speed, 2);
            _os.write(speeds, 3);
            _os.write(telcom, 4);
            _os.write(unicom, 5);
            _os.write(unicomtype, 6);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ckey, 0, true);
            _is.read(nettype, 1, false);
            _is.read(speed, 2, false);
            _is.read(speeds, 3, false);
            _is.read(telcom, 4, false);
            _is.read(unicom, 5, false);
            _is.read(unicomtype, 6, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(ckey,"ckey");
            _ds.display(nettype,"nettype");
            _ds.display(speed,"speed");
            _ds.display(speeds,"speeds");
            _ds.display(telcom,"telcom");
            _ds.display(unicom,"unicom");
            _ds.display(unicomtype,"unicomtype");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(ckey, true);
            _ds.displaySimple(nettype, true);
            _ds.displaySimple(speed, true);
            _ds.displaySimple(speeds, true);
            _ds.displaySimple(telcom, true);
            _ds.displaySimple(unicom, true);
            _ds.displaySimple(unicomtype, false);
            return _os;
        }
    public:
        std::string ckey;
        taf::Int32 nettype;
        taf::Int32 speed;
        std::string speeds;
        std::string telcom;
        std::string unicom;
        taf::Int32 unicomtype;
    };
    inline bool operator==(const VideoUserInfo&l, const VideoUserInfo&r)
    {
        return l.ckey == r.ckey && l.nettype == r.nettype && l.speed == r.speed && l.speeds == r.speeds && l.telcom == r.telcom && l.unicom == r.unicom && l.unicomtype == r.unicomtype;
    }
    inline bool operator!=(const VideoUserInfo&l, const VideoUserInfo&r)
    {
        return !(l == r);
    }

    struct GetVInfoRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.GetVInfoRequest";
        }
        static string MD5()
        {
            return "ba7bbd0978b7abf0b0bc452562f8c61d";
        }
        GetVInfoRequest()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(playInfo, 0);
            _os.write(appInfo, 1);
            _os.write(userInfo, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(playInfo, 0, true);
            _is.read(appInfo, 1, true);
            _is.read(userInfo, 2, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(playInfo,"playInfo");
            _ds.display(appInfo,"appInfo");
            _ds.display(userInfo,"userInfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(playInfo, true);
            _ds.displaySimple(appInfo, true);
            _ds.displaySimple(userInfo, false);
            return _os;
        }
    public:
        jce::VideoPlayInfo playInfo;
        jce::VideoAppInfo appInfo;
        jce::VideoUserInfo userInfo;
    };
    inline bool operator==(const GetVInfoRequest&l, const GetVInfoRequest&r)
    {
        return l.playInfo == r.playInfo && l.appInfo == r.appInfo && l.userInfo == r.userInfo;
    }
    inline bool operator!=(const GetVInfoRequest&l, const GetVInfoRequest&r)
    {
        return !(l == r);
    }

    struct GetVInfoResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.GetVInfoResponse";
        }
        static string MD5()
        {
            return "26159cf77dcb9fe1c64b57dae580ccae";
        }
        GetVInfoResponse()
        :errCode(0),videoInfo("")
        {
        }
        void resetDefautlt()
        {
            errCode = 0;
            videoInfo = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(errCode, 0);
            _os.write(videoInfo, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errCode, 0, true);
            _is.read(videoInfo, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(errCode,"errCode");
            _ds.display(videoInfo,"videoInfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(errCode, true);
            _ds.displaySimple(videoInfo, false);
            return _os;
        }
    public:
        taf::Int32 errCode;
        std::string videoInfo;
    };
    inline bool operator==(const GetVInfoResponse&l, const GetVInfoResponse&r)
    {
        return l.errCode == r.errCode && l.videoInfo == r.videoInfo;
    }
    inline bool operator!=(const GetVInfoResponse&l, const GetVInfoResponse&r)
    {
        return !(l == r);
    }


}

#define jce_VideoPlayInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.vids,b.vids);jce_copy_struct(a.defn,b.defn);jce_copy_struct(a.dtype,b.dtype);jce_copy_struct(a.otype,b.otype);jce_copy_struct(a.callback,b.callback);jce_copy_struct(a.callvar,b.callvar);jce_copy_struct(a.ptime,b.ptime);jce_copy_struct(a.clip,b.clip);jce_copy_struct(a.dlna,b.dlna);jce_copy_struct(a.fhdswitch,b.fhdswitch);jce_copy_struct(a.charge,b.charge);jce_copy_struct(a.defsrc,b.defsrc);

#define jce_VideoAppInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.platform,b.platform);jce_copy_struct(a.device,b.device);jce_copy_struct(a.hevclv,b.hevclv);jce_copy_struct(a.sdtfrom,b.sdtfrom);jce_copy_struct(a.randnum,b.randnum);jce_copy_struct(a.encryptver,b.encryptver);jce_copy_struct(a.incver,b.incver);jce_copy_struct(a.fp2p,b.fp2p);jce_copy_struct(a.defnpayver,b.defnpayver);jce_copy_struct(a.sphls,b.sphls);jce_copy_struct(a.sphttps,b.sphttps);jce_copy_struct(a.spdrm,b.spdrm);

#define jce_VideoUserInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.ckey,b.ckey);jce_copy_struct(a.nettype,b.nettype);jce_copy_struct(a.speed,b.speed);jce_copy_struct(a.speeds,b.speeds);jce_copy_struct(a.telcom,b.telcom);jce_copy_struct(a.unicom,b.unicom);jce_copy_struct(a.unicomtype,b.unicomtype);

#define jce_GetVInfoRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.playInfo,b.playInfo);jce_copy_struct(a.appInfo,b.appInfo);jce_copy_struct(a.userInfo,b.userInfo);

#define jce_GetVInfoResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.errCode,b.errCode);jce_copy_struct(a.videoInfo,b.videoInfo);



#endif
