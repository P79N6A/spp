// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 3.1.1.2 by WSRD Tencent.
// Generated from `qqvideo_debug.jce'
// **********************************************************************

#ifndef __QQVIDEO_DEBUG_H_
#define __QQVIDEO_DEBUG_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
using namespace std;


namespace jce
{
    struct DebugInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.DebugInfo";
        }
        static string MD5()
        {
            return "6cf1348cdd69f924109dd734bc911528";
        }
        DebugInfo()
        :info(""),info1(""),info2(""),info3(""),info4(""),info5("")
        {
        }
        void resetDefautlt()
        {
            info = "";
            info1 = "";
            info2 = "";
            info3 = "";
            info4 = "";
            info5 = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(info, 0);
            _os.write(info1, 1);
            _os.write(info2, 2);
            _os.write(info3, 3);
            _os.write(info4, 4);
            _os.write(info5, 5);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(info, 0, false);
            _is.read(info1, 1, false);
            _is.read(info2, 2, false);
            _is.read(info3, 3, false);
            _is.read(info4, 4, false);
            _is.read(info5, 5, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(info,"info");
            _ds.display(info1,"info1");
            _ds.display(info2,"info2");
            _ds.display(info3,"info3");
            _ds.display(info4,"info4");
            _ds.display(info5,"info5");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(info, true);
            _ds.displaySimple(info1, true);
            _ds.displaySimple(info2, true);
            _ds.displaySimple(info3, true);
            _ds.displaySimple(info4, true);
            _ds.displaySimple(info5, false);
            return _os;
        }
    public:
        std::string info;
        std::string info1;
        std::string info2;
        std::string info3;
        std::string info4;
        std::string info5;
    };
    inline bool operator==(const DebugInfo&l, const DebugInfo&r)
    {
        return l.info == r.info && l.info1 == r.info1 && l.info2 == r.info2 && l.info3 == r.info3 && l.info4 == r.info4 && l.info5 == r.info5;
    }
    inline bool operator!=(const DebugInfo&l, const DebugInfo&r)
    {
        return !(l == r);
    }


}

#define jce_DebugInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.info,b.info);jce_copy_struct(a.info1,b.info1);jce_copy_struct(a.info2,b.info2);jce_copy_struct(a.info3,b.info3);jce_copy_struct(a.info4,b.info4);jce_copy_struct(a.info5,b.info5);



#endif
