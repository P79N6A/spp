// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 3.1.1.2 by WSRD Tencent.
// Generated from `qqvideo_personality.jce'
// **********************************************************************

#ifndef __QQVIDEO_PERSONALITY_H_
#define __QQVIDEO_PERSONALITY_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
using namespace std;
#include "qqvideo_common.h"


namespace jce
{
    struct ONAActiveButton : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.ONAActiveButton";
        }
        static string MD5()
        {
            return "0c1d945735360d4e3752e1b2d448ba0c";
        }
        ONAActiveButton()
        :title(""),imgUrl(""),dataKey("")
        {
        }
        void resetDefautlt()
        {
            title = "";
            imgUrl = "";
            dataKey = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(title, 0);
            _os.write(imgUrl, 1);
            _os.write(dataKey, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(title, 0, true);
            _is.read(imgUrl, 1, true);
            _is.read(dataKey, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(title,"title");
            _ds.display(imgUrl,"imgUrl");
            _ds.display(dataKey,"dataKey");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(title, true);
            _ds.displaySimple(imgUrl, true);
            _ds.displaySimple(dataKey, false);
            return _os;
        }
    public:
        std::string title;
        std::string imgUrl;
        std::string dataKey;
    };
    inline bool operator==(const ONAActiveButton&l, const ONAActiveButton&r)
    {
        return l.title == r.title && l.imgUrl == r.imgUrl && l.dataKey == r.dataKey;
    }
    inline bool operator!=(const ONAActiveButton&l, const ONAActiveButton&r)
    {
        return !(l == r);
    }

    struct UserAction : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.UserAction";
        }
        static string MD5()
        {
            return "88ceb13375e8d5bea851edb79976e246";
        }
        UserAction()
        :actionType(0),isActive(true),type("")
        {
        }
        void resetDefautlt()
        {
            actionType = 0;
            isActive = true;
            type = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(actionType, 0);
            _os.write(isActive, 1);
            _os.write(activeButton, 2);
            _os.write(inActiveButton, 3);
            _os.write(videoAttentItem, 4);
            _os.write(jumpAction, 5);
            _os.write(type, 6);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(actionType, 0, true);
            _is.read(isActive, 1, true);
            _is.read(activeButton, 2, true);
            _is.read(inActiveButton, 3, true);
            _is.read(videoAttentItem, 4, false);
            _is.read(jumpAction, 5, false);
            _is.read(type, 6, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(actionType,"actionType");
            _ds.display(isActive,"isActive");
            _ds.display(activeButton,"activeButton");
            _ds.display(inActiveButton,"inActiveButton");
            _ds.display(videoAttentItem,"videoAttentItem");
            _ds.display(jumpAction,"jumpAction");
            _ds.display(type,"type");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(actionType, true);
            _ds.displaySimple(isActive, true);
            _ds.displaySimple(activeButton, true);
            _ds.displaySimple(inActiveButton, true);
            _ds.displaySimple(videoAttentItem, true);
            _ds.displaySimple(jumpAction, true);
            _ds.displaySimple(type, false);
            return _os;
        }
    public:
        taf::Int32 actionType;
        taf::Bool isActive;
        jce::ONAActiveButton activeButton;
        jce::ONAActiveButton inActiveButton;
        jce::VideoAttentItem videoAttentItem;
        jce::Action jumpAction;
        std::string type;
    };
    inline bool operator==(const UserAction&l, const UserAction&r)
    {
        return l.actionType == r.actionType && l.isActive == r.isActive && l.activeButton == r.activeButton && l.inActiveButton == r.inActiveButton && l.videoAttentItem == r.videoAttentItem && l.jumpAction == r.jumpAction && l.type == r.type;
    }
    inline bool operator!=(const UserAction&l, const UserAction&r)
    {
        return !(l == r);
    }

    struct ONAUserActionTitle : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.ONAUserActionTitle";
        }
        static string MD5()
        {
            return "99029a0fcd439dcbd4199ff4987c983f";
        }
        ONAUserActionTitle()
        :title(""),subTitle(""),reportKey(""),reportParams("")
        {
        }
        void resetDefautlt()
        {
            title = "";
            subTitle = "";
            reportKey = "";
            reportParams = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(title, 0);
            _os.write(subTitle, 1);
            _os.write(image, 2);
            _os.write(userActions, 3);
            _os.write(reportKey, 4);
            _os.write(reportParams, 5);
            _os.write(action, 6);
            _os.write(channelInsertItem, 7);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(title, 0, true);
            _is.read(subTitle, 1, false);
            _is.read(image, 2, false);
            _is.read(userActions, 3, false);
            _is.read(reportKey, 4, false);
            _is.read(reportParams, 5, false);
            _is.read(action, 6, false);
            _is.read(channelInsertItem, 7, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(title,"title");
            _ds.display(subTitle,"subTitle");
            _ds.display(image,"image");
            _ds.display(userActions,"userActions");
            _ds.display(reportKey,"reportKey");
            _ds.display(reportParams,"reportParams");
            _ds.display(action,"action");
            _ds.display(channelInsertItem,"channelInsertItem");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(title, true);
            _ds.displaySimple(subTitle, true);
            _ds.displaySimple(image, true);
            _ds.displaySimple(userActions, true);
            _ds.displaySimple(reportKey, true);
            _ds.displaySimple(reportParams, true);
            _ds.displaySimple(action, true);
            _ds.displaySimple(channelInsertItem, false);
            return _os;
        }
    public:
        std::string title;
        std::string subTitle;
        jce::VideoImage image;
        vector<jce::UserAction> userActions;
        std::string reportKey;
        std::string reportParams;
        jce::Action action;
        jce::ChannelInsertItem channelInsertItem;
    };
    inline bool operator==(const ONAUserActionTitle&l, const ONAUserActionTitle&r)
    {
        return l.title == r.title && l.subTitle == r.subTitle && l.image == r.image && l.userActions == r.userActions && l.reportKey == r.reportKey && l.reportParams == r.reportParams && l.action == r.action && l.channelInsertItem == r.channelInsertItem;
    }
    inline bool operator!=(const ONAUserActionTitle&l, const ONAUserActionTitle&r)
    {
        return !(l == r);
    }

    struct ONAThemeUserActionTitle : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.ONAThemeUserActionTitle";
        }
        static string MD5()
        {
            return "eb1d4f1a676f09a31b7a3cd260d812be";
        }
        ONAThemeUserActionTitle()
        :titleColor("")
        {
        }
        void resetDefautlt()
        {
            titleColor = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(actionTitle, 0);
            _os.write(titleColor, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(actionTitle, 0, true);
            _is.read(titleColor, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(actionTitle,"actionTitle");
            _ds.display(titleColor,"titleColor");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(actionTitle, true);
            _ds.displaySimple(titleColor, false);
            return _os;
        }
    public:
        jce::ONAUserActionTitle actionTitle;
        std::string titleColor;
    };
    inline bool operator==(const ONAThemeUserActionTitle&l, const ONAThemeUserActionTitle&r)
    {
        return l.actionTitle == r.actionTitle && l.titleColor == r.titleColor;
    }
    inline bool operator!=(const ONAThemeUserActionTitle&l, const ONAThemeUserActionTitle&r)
    {
        return !(l == r);
    }

    struct FeedbackActionRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.FeedbackActionRequest";
        }
        static string MD5()
        {
            return "1f47da24b69e655580a48d1f7cab279a";
        }
        FeedbackActionRequest()
        :actionType(0),dataKey(""),type("")
        {
        }
        void resetDefautlt()
        {
            actionType = 0;
            dataKey = "";
            type = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(actionType, 0);
            _os.write(dataKey, 1);
            _os.write(type, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(actionType, 0, true);
            _is.read(dataKey, 1, false);
            _is.read(type, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(actionType,"actionType");
            _ds.display(dataKey,"dataKey");
            _ds.display(type,"type");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(actionType, true);
            _ds.displaySimple(dataKey, true);
            _ds.displaySimple(type, false);
            return _os;
        }
    public:
        taf::Int32 actionType;
        std::string dataKey;
        std::string type;
    };
    inline bool operator==(const FeedbackActionRequest&l, const FeedbackActionRequest&r)
    {
        return l.actionType == r.actionType && l.dataKey == r.dataKey && l.type == r.type;
    }
    inline bool operator!=(const FeedbackActionRequest&l, const FeedbackActionRequest&r)
    {
        return !(l == r);
    }

    struct FeedbackActionResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.FeedbackActionResponse";
        }
        static string MD5()
        {
            return "30db60856c3f115ddfc036315f639a05";
        }
        FeedbackActionResponse()
        :errCode(0)
        {
        }
        void resetDefautlt()
        {
            errCode = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(errCode, 0);
            _os.write(uiData, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errCode, 0, true);
            _is.read(uiData, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(errCode,"errCode");
            _ds.display(uiData,"uiData");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(errCode, true);
            _ds.displaySimple(uiData, false);
            return _os;
        }
    public:
        taf::Int32 errCode;
        vector<jce::TempletLine> uiData;
    };
    inline bool operator==(const FeedbackActionResponse&l, const FeedbackActionResponse&r)
    {
        return l.errCode == r.errCode && l.uiData == r.uiData;
    }
    inline bool operator!=(const FeedbackActionResponse&l, const FeedbackActionResponse&r)
    {
        return !(l == r);
    }

    struct VideoPreviewActionRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.VideoPreviewActionRequest";
        }
        static string MD5()
        {
            return "262dc96c0f671c473e78719d51b59380";
        }
        VideoPreviewActionRequest()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(previewPoster, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(previewPoster, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(previewPoster,"previewPoster");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(previewPoster, false);
            return _os;
        }
    public:
        jce::Poster previewPoster;
    };
    inline bool operator==(const VideoPreviewActionRequest&l, const VideoPreviewActionRequest&r)
    {
        return l.previewPoster == r.previewPoster;
    }
    inline bool operator!=(const VideoPreviewActionRequest&l, const VideoPreviewActionRequest&r)
    {
        return !(l == r);
    }

    struct VideoPreviewActionResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.VideoPreviewActionResponse";
        }
        static string MD5()
        {
            return "8014e94b0b46b980221f0d70c4918751";
        }
        VideoPreviewActionResponse()
        :errCode(0)
        {
        }
        void resetDefautlt()
        {
            errCode = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(errCode, 0);
            _os.write(videoItem, 1);
            _os.write(userActions, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errCode, 0, true);
            _is.read(videoItem, 1, false);
            _is.read(userActions, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(errCode,"errCode");
            _ds.display(videoItem,"videoItem");
            _ds.display(userActions,"userActions");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(errCode, true);
            _ds.displaySimple(videoItem, true);
            _ds.displaySimple(userActions, false);
            return _os;
        }
    public:
        taf::Int32 errCode;
        jce::VideoItemData videoItem;
        vector<jce::UserAction> userActions;
    };
    inline bool operator==(const VideoPreviewActionResponse&l, const VideoPreviewActionResponse&r)
    {
        return l.errCode == r.errCode && l.videoItem == r.videoItem && l.userActions == r.userActions;
    }
    inline bool operator!=(const VideoPreviewActionResponse&l, const VideoPreviewActionResponse&r)
    {
        return !(l == r);
    }

    struct PersonalityPageRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.PersonalityPageRequest";
        }
        static string MD5()
        {
            return "a3a212cd2be506fc19df0be91a8ec4e1";
        }
        PersonalityPageRequest()
        :type(""),dataKey(""),pageContext(""),hasCache(0),requestScenes(0),lastGroupId(""),routeKey("")
        {
        }
        void resetDefautlt()
        {
            type = "";
            dataKey = "";
            pageContext = "";
            hasCache = 0;
            requestScenes = 0;
            lastGroupId = "";
            routeKey = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(type, 0);
            _os.write(dataKey, 1);
            _os.write(pageContext, 2);
            _os.write(hasCache, 3);
            _os.write(requestScenes, 4);
            _os.write(lastGroupId, 5);
            _os.write(routeKey, 6);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(type, 0, false);
            _is.read(dataKey, 1, false);
            _is.read(pageContext, 2, false);
            _is.read(hasCache, 3, false);
            _is.read(requestScenes, 4, false);
            _is.read(lastGroupId, 5, false);
            _is.read(routeKey, 6, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(type,"type");
            _ds.display(dataKey,"dataKey");
            _ds.display(pageContext,"pageContext");
            _ds.display(hasCache,"hasCache");
            _ds.display(requestScenes,"requestScenes");
            _ds.display(lastGroupId,"lastGroupId");
            _ds.display(routeKey,"routeKey");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(type, true);
            _ds.displaySimple(dataKey, true);
            _ds.displaySimple(pageContext, true);
            _ds.displaySimple(hasCache, true);
            _ds.displaySimple(requestScenes, true);
            _ds.displaySimple(lastGroupId, true);
            _ds.displaySimple(routeKey, false);
            return _os;
        }
    public:
        std::string type;
        std::string dataKey;
        std::string pageContext;
        taf::Int32 hasCache;
        taf::Int32 requestScenes;
        std::string lastGroupId;
        std::string routeKey;
    };
    inline bool operator==(const PersonalityPageRequest&l, const PersonalityPageRequest&r)
    {
        return l.type == r.type && l.dataKey == r.dataKey && l.pageContext == r.pageContext && l.hasCache == r.hasCache && l.requestScenes == r.requestScenes && l.lastGroupId == r.lastGroupId && l.routeKey == r.routeKey;
    }
    inline bool operator!=(const PersonalityPageRequest&l, const PersonalityPageRequest&r)
    {
        return !(l == r);
    }

    struct PersonalityPageResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.PersonalityPageResponse";
        }
        static string MD5()
        {
            return "7adeeaf84b7f4d4e4783f4fd06897317";
        }
        PersonalityPageResponse()
        :errCode(0),pageContext(""),isHaveNextPage(true),title(""),subTitle(""),titleUiType(0),reportParams(""),reportKey("")
        {
        }
        void resetDefautlt()
        {
            errCode = 0;
            pageContext = "";
            isHaveNextPage = true;
            title = "";
            subTitle = "";
            titleUiType = 0;
            reportParams = "";
            reportKey = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(errCode, 0);
            _os.write(uiData, 1);
            _os.write(pageContext, 2);
            _os.write(isHaveNextPage, 3);
            _os.write(title, 5);
            _os.write(subTitle, 6);
            _os.write(titleUiType, 7);
            _os.write(reportParams, 8);
            _os.write(reportKey, 9);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errCode, 0, true);
            _is.read(uiData, 1, false);
            _is.read(pageContext, 2, false);
            _is.read(isHaveNextPage, 3, false);
            _is.read(title, 5, false);
            _is.read(subTitle, 6, false);
            _is.read(titleUiType, 7, false);
            _is.read(reportParams, 8, false);
            _is.read(reportKey, 9, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(errCode,"errCode");
            _ds.display(uiData,"uiData");
            _ds.display(pageContext,"pageContext");
            _ds.display(isHaveNextPage,"isHaveNextPage");
            _ds.display(title,"title");
            _ds.display(subTitle,"subTitle");
            _ds.display(titleUiType,"titleUiType");
            _ds.display(reportParams,"reportParams");
            _ds.display(reportKey,"reportKey");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(errCode, true);
            _ds.displaySimple(uiData, true);
            _ds.displaySimple(pageContext, true);
            _ds.displaySimple(isHaveNextPage, true);
            _ds.displaySimple(title, true);
            _ds.displaySimple(subTitle, true);
            _ds.displaySimple(titleUiType, true);
            _ds.displaySimple(reportParams, true);
            _ds.displaySimple(reportKey, false);
            return _os;
        }
    public:
        taf::Int32 errCode;
        vector<jce::TempletLine> uiData;
        std::string pageContext;
        taf::Bool isHaveNextPage;
        std::string title;
        std::string subTitle;
        taf::Int32 titleUiType;
        std::string reportParams;
        std::string reportKey;
    };
    inline bool operator==(const PersonalityPageResponse&l, const PersonalityPageResponse&r)
    {
        return l.errCode == r.errCode && l.uiData == r.uiData && l.pageContext == r.pageContext && l.isHaveNextPage == r.isHaveNextPage && l.title == r.title && l.subTitle == r.subTitle && l.titleUiType == r.titleUiType && l.reportParams == r.reportParams && l.reportKey == r.reportKey;
    }
    inline bool operator!=(const PersonalityPageResponse&l, const PersonalityPageResponse&r)
    {
        return !(l == r);
    }

    struct FeedbackInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.FeedbackInfo";
        }
        static string MD5()
        {
            return "1f47da24b69e655580a48d1f7cab279a";
        }
        FeedbackInfo()
        :actionType(0),dataKey(""),type("")
        {
        }
        void resetDefautlt()
        {
            actionType = 0;
            dataKey = "";
            type = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(actionType, 0);
            _os.write(dataKey, 1);
            _os.write(type, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(actionType, 0, true);
            _is.read(dataKey, 1, false);
            _is.read(type, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(actionType,"actionType");
            _ds.display(dataKey,"dataKey");
            _ds.display(type,"type");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(actionType, true);
            _ds.displaySimple(dataKey, true);
            _ds.displaySimple(type, false);
            return _os;
        }
    public:
        taf::Int32 actionType;
        std::string dataKey;
        std::string type;
    };
    inline bool operator==(const FeedbackInfo&l, const FeedbackInfo&r)
    {
        return l.actionType == r.actionType && l.dataKey == r.dataKey && l.type == r.type;
    }
    inline bool operator!=(const FeedbackInfo&l, const FeedbackInfo&r)
    {
        return !(l == r);
    }

    struct FeedbackActionBatchRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.FeedbackActionBatchRequest";
        }
        static string MD5()
        {
            return "3f9794a347542abcc99fea7891edbadf";
        }
        FeedbackActionBatchRequest()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(feedbackInfoList, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(feedbackInfoList, 0, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(feedbackInfoList,"feedbackInfoList");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(feedbackInfoList, false);
            return _os;
        }
    public:
        vector<jce::FeedbackInfo> feedbackInfoList;
    };
    inline bool operator==(const FeedbackActionBatchRequest&l, const FeedbackActionBatchRequest&r)
    {
        return l.feedbackInfoList == r.feedbackInfoList;
    }
    inline bool operator!=(const FeedbackActionBatchRequest&l, const FeedbackActionBatchRequest&r)
    {
        return !(l == r);
    }

    struct FeedbackActionBatchResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.FeedbackActionBatchResponse";
        }
        static string MD5()
        {
            return "05511bece4a2b65e1361cf6867461c97";
        }
        FeedbackActionBatchResponse()
        :errCode(0)
        {
        }
        void resetDefautlt()
        {
            errCode = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(errCode, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errCode, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(errCode,"errCode");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(errCode, false);
            return _os;
        }
    public:
        taf::Int32 errCode;
    };
    inline bool operator==(const FeedbackActionBatchResponse&l, const FeedbackActionBatchResponse&r)
    {
        return l.errCode == r.errCode;
    }
    inline bool operator!=(const FeedbackActionBatchResponse&l, const FeedbackActionBatchResponse&r)
    {
        return !(l == r);
    }


}

#define jce_ONAActiveButton_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.title,b.title);jce_copy_struct(a.imgUrl,b.imgUrl);jce_copy_struct(a.dataKey,b.dataKey);

#define jce_UserAction_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.actionType,b.actionType);jce_copy_struct(a.isActive,b.isActive);jce_copy_struct(a.activeButton,b.activeButton);jce_copy_struct(a.inActiveButton,b.inActiveButton);jce_copy_struct(a.videoAttentItem,b.videoAttentItem);jce_copy_struct(a.jumpAction,b.jumpAction);jce_copy_struct(a.type,b.type);

#define jce_ONAUserActionTitle_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.title,b.title);jce_copy_struct(a.subTitle,b.subTitle);jce_copy_struct(a.image,b.image);jce_copy_struct(a.userActions,b.userActions);jce_copy_struct(a.reportKey,b.reportKey);jce_copy_struct(a.reportParams,b.reportParams);jce_copy_struct(a.action,b.action);jce_copy_struct(a.channelInsertItem,b.channelInsertItem);

#define jce_ONAThemeUserActionTitle_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.actionTitle,b.actionTitle);jce_copy_struct(a.titleColor,b.titleColor);

#define jce_FeedbackActionRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.actionType,b.actionType);jce_copy_struct(a.dataKey,b.dataKey);jce_copy_struct(a.type,b.type);

#define jce_FeedbackActionResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.errCode,b.errCode);jce_copy_struct(a.uiData,b.uiData);

#define jce_VideoPreviewActionRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.previewPoster,b.previewPoster);

#define jce_VideoPreviewActionResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.errCode,b.errCode);jce_copy_struct(a.videoItem,b.videoItem);jce_copy_struct(a.userActions,b.userActions);

#define jce_PersonalityPageRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.type,b.type);jce_copy_struct(a.dataKey,b.dataKey);jce_copy_struct(a.pageContext,b.pageContext);jce_copy_struct(a.hasCache,b.hasCache);jce_copy_struct(a.requestScenes,b.requestScenes);jce_copy_struct(a.lastGroupId,b.lastGroupId);jce_copy_struct(a.routeKey,b.routeKey);

#define jce_PersonalityPageResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.errCode,b.errCode);jce_copy_struct(a.uiData,b.uiData);jce_copy_struct(a.pageContext,b.pageContext);jce_copy_struct(a.isHaveNextPage,b.isHaveNextPage);jce_copy_struct(a.title,b.title);jce_copy_struct(a.subTitle,b.subTitle);jce_copy_struct(a.titleUiType,b.titleUiType);jce_copy_struct(a.reportParams,b.reportParams);jce_copy_struct(a.reportKey,b.reportKey);

#define jce_FeedbackInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.actionType,b.actionType);jce_copy_struct(a.dataKey,b.dataKey);jce_copy_struct(a.type,b.type);

#define jce_FeedbackActionBatchRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.feedbackInfoList,b.feedbackInfoList);

#define jce_FeedbackActionBatchResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.errCode,b.errCode);



#endif
