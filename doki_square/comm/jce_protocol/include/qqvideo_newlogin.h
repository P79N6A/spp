// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 3.1.1.2 by WSRD Tencent.
// Generated from `qqvideo_newlogin.jce'
// **********************************************************************

#ifndef __QQVIDEO_NEWLOGIN_H_
#define __QQVIDEO_NEWLOGIN_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
using namespace std;


namespace jce
{
    enum LoginErrCode
    {
        SUCC = 0,
        FAIL = 1,
        ERR_REQ_PACKAGE = 1001,
        ERR_TIMEOUT_WXPROXY = 1002,
        ERR_INVALID_WXTOKEN = 1003,
        ERR_CREATE_VUSER = 1004,
        ERR_UPDATE_ID = 1005,
        ERR_UPDATE_PROFILE = 1006,
        ERR_OVERLOAD = 1007,
        ERR_SNS_UPDATE = 1008,
        ERR_TIMEOUT_M2UREAD = 1009,
        ERR_WXPROXY = 1010,
        ERR_M2UREAD = 1011,
        ERR_WRITE_UIN = 1012,
        ERR_GET_VIDEOTOKEN = 1013,
        ERR_GET_VIDEOTOKEN_TIMEOUT = 1014,
        ERR_CHECK_VIDEOTOKEN = 1015,
        ERR_CHECK_VIDEOTOKEN_TIMEOUT = 1016,
        ERR_GET_WXQQ = 1017,
        ERR_READ_PROFILE_TIMEOUT = 1018,
        ERR_READ_PROFILE = 1019,
        ERR_CHECK_PTLOGIN = 1020,
        ERR_CHECK_PTLOGIN_TIMEOUT = 1021,
        ERR_READ_QQ_PROFILE = 1022,
    };
    inline string etos(const LoginErrCode & e)
    {
        switch(e)
        {
            case SUCC: return "SUCC";
            case FAIL: return "FAIL";
            case ERR_REQ_PACKAGE: return "ERR_REQ_PACKAGE";
            case ERR_TIMEOUT_WXPROXY: return "ERR_TIMEOUT_WXPROXY";
            case ERR_INVALID_WXTOKEN: return "ERR_INVALID_WXTOKEN";
            case ERR_CREATE_VUSER: return "ERR_CREATE_VUSER";
            case ERR_UPDATE_ID: return "ERR_UPDATE_ID";
            case ERR_UPDATE_PROFILE: return "ERR_UPDATE_PROFILE";
            case ERR_OVERLOAD: return "ERR_OVERLOAD";
            case ERR_SNS_UPDATE: return "ERR_SNS_UPDATE";
            case ERR_TIMEOUT_M2UREAD: return "ERR_TIMEOUT_M2UREAD";
            case ERR_WXPROXY: return "ERR_WXPROXY";
            case ERR_M2UREAD: return "ERR_M2UREAD";
            case ERR_WRITE_UIN: return "ERR_WRITE_UIN";
            case ERR_GET_VIDEOTOKEN: return "ERR_GET_VIDEOTOKEN";
            case ERR_GET_VIDEOTOKEN_TIMEOUT: return "ERR_GET_VIDEOTOKEN_TIMEOUT";
            case ERR_CHECK_VIDEOTOKEN: return "ERR_CHECK_VIDEOTOKEN";
            case ERR_CHECK_VIDEOTOKEN_TIMEOUT: return "ERR_CHECK_VIDEOTOKEN_TIMEOUT";
            case ERR_GET_WXQQ: return "ERR_GET_WXQQ";
            case ERR_READ_PROFILE_TIMEOUT: return "ERR_READ_PROFILE_TIMEOUT";
            case ERR_READ_PROFILE: return "ERR_READ_PROFILE";
            case ERR_CHECK_PTLOGIN: return "ERR_CHECK_PTLOGIN";
            case ERR_CHECK_PTLOGIN_TIMEOUT: return "ERR_CHECK_PTLOGIN_TIMEOUT";
            case ERR_READ_QQ_PROFILE: return "ERR_READ_QQ_PROFILE";
            default: return "";
        }
    }
    inline int stoe(const string & s, LoginErrCode & e)
    {
        if(s == "SUCC")  { e=SUCC; return 0;}
        if(s == "FAIL")  { e=FAIL; return 0;}
        if(s == "ERR_REQ_PACKAGE")  { e=ERR_REQ_PACKAGE; return 0;}
        if(s == "ERR_TIMEOUT_WXPROXY")  { e=ERR_TIMEOUT_WXPROXY; return 0;}
        if(s == "ERR_INVALID_WXTOKEN")  { e=ERR_INVALID_WXTOKEN; return 0;}
        if(s == "ERR_CREATE_VUSER")  { e=ERR_CREATE_VUSER; return 0;}
        if(s == "ERR_UPDATE_ID")  { e=ERR_UPDATE_ID; return 0;}
        if(s == "ERR_UPDATE_PROFILE")  { e=ERR_UPDATE_PROFILE; return 0;}
        if(s == "ERR_OVERLOAD")  { e=ERR_OVERLOAD; return 0;}
        if(s == "ERR_SNS_UPDATE")  { e=ERR_SNS_UPDATE; return 0;}
        if(s == "ERR_TIMEOUT_M2UREAD")  { e=ERR_TIMEOUT_M2UREAD; return 0;}
        if(s == "ERR_WXPROXY")  { e=ERR_WXPROXY; return 0;}
        if(s == "ERR_M2UREAD")  { e=ERR_M2UREAD; return 0;}
        if(s == "ERR_WRITE_UIN")  { e=ERR_WRITE_UIN; return 0;}
        if(s == "ERR_GET_VIDEOTOKEN")  { e=ERR_GET_VIDEOTOKEN; return 0;}
        if(s == "ERR_GET_VIDEOTOKEN_TIMEOUT")  { e=ERR_GET_VIDEOTOKEN_TIMEOUT; return 0;}
        if(s == "ERR_CHECK_VIDEOTOKEN")  { e=ERR_CHECK_VIDEOTOKEN; return 0;}
        if(s == "ERR_CHECK_VIDEOTOKEN_TIMEOUT")  { e=ERR_CHECK_VIDEOTOKEN_TIMEOUT; return 0;}
        if(s == "ERR_GET_WXQQ")  { e=ERR_GET_WXQQ; return 0;}
        if(s == "ERR_READ_PROFILE_TIMEOUT")  { e=ERR_READ_PROFILE_TIMEOUT; return 0;}
        if(s == "ERR_READ_PROFILE")  { e=ERR_READ_PROFILE; return 0;}
        if(s == "ERR_CHECK_PTLOGIN")  { e=ERR_CHECK_PTLOGIN; return 0;}
        if(s == "ERR_CHECK_PTLOGIN_TIMEOUT")  { e=ERR_CHECK_PTLOGIN_TIMEOUT; return 0;}
        if(s == "ERR_READ_QQ_PROFILE")  { e=ERR_READ_QQ_PROFILE; return 0;}

        return -1;
    }

    enum DevicePlatType
    {
        DEV_PLAT_IPAD = 5,
        DEV_PLAT_APAD = 6,
        DEV_PLAT_IPHONE = 7,
        DEV_PLAT_APHONE = 8,
    };
    inline string etos(const DevicePlatType & e)
    {
        switch(e)
        {
            case DEV_PLAT_IPAD: return "DEV_PLAT_IPAD";
            case DEV_PLAT_APAD: return "DEV_PLAT_APAD";
            case DEV_PLAT_IPHONE: return "DEV_PLAT_IPHONE";
            case DEV_PLAT_APHONE: return "DEV_PLAT_APHONE";
            default: return "";
        }
    }
    inline int stoe(const string & s, DevicePlatType & e)
    {
        if(s == "DEV_PLAT_IPAD")  { e=DEV_PLAT_IPAD; return 0;}
        if(s == "DEV_PLAT_APAD")  { e=DEV_PLAT_APAD; return 0;}
        if(s == "DEV_PLAT_IPHONE")  { e=DEV_PLAT_IPHONE; return 0;}
        if(s == "DEV_PLAT_APHONE")  { e=DEV_PLAT_APHONE; return 0;}

        return -1;
    }

    enum ETokenKeyType
    {
        EnumSkey = 1,
        EnumLsky = 7,
        EnumVuserkey = 9,
        Enum321Key = 50,
        EnumAccessToken = 100,
        EnumWxCode = 101,
    };
    inline string etos(const ETokenKeyType & e)
    {
        switch(e)
        {
            case EnumSkey: return "EnumSkey";
            case EnumLsky: return "EnumLsky";
            case EnumVuserkey: return "EnumVuserkey";
            case Enum321Key: return "Enum321Key";
            case EnumAccessToken: return "EnumAccessToken";
            case EnumWxCode: return "EnumWxCode";
            default: return "";
        }
    }
    inline int stoe(const string & s, ETokenKeyType & e)
    {
        if(s == "EnumSkey")  { e=EnumSkey; return 0;}
        if(s == "EnumLsky")  { e=EnumLsky; return 0;}
        if(s == "EnumVuserkey")  { e=EnumVuserkey; return 0;}
        if(s == "Enum321Key")  { e=Enum321Key; return 0;}
        if(s == "EnumAccessToken")  { e=EnumAccessToken; return 0;}
        if(s == "EnumWxCode")  { e=EnumWxCode; return 0;}

        return -1;
    }

    struct STDevInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.STDevInfo";
        }
        static string MD5()
        {
            return "b961f54ea9d16c2e51c2c02340483d7d";
        }
        STDevInfo()
        :wDevPlatType(0),pushToken(""),guid(""),devid(""),strFromInfo("")
        {
        }
        void resetDefautlt()
        {
            wDevPlatType = 0;
            pushToken = "";
            guid = "";
            devid = "";
            strFromInfo = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(wDevPlatType, 1);
            _os.write(pushToken, 2);
            _os.write(guid, 3);
            _os.write(devid, 4);
            _os.write(strFromInfo, 5);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(wDevPlatType, 1, true);
            _is.read(pushToken, 2, false);
            _is.read(guid, 3, false);
            _is.read(devid, 4, false);
            _is.read(strFromInfo, 5, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(wDevPlatType,"wDevPlatType");
            _ds.display(pushToken,"pushToken");
            _ds.display(guid,"guid");
            _ds.display(devid,"devid");
            _ds.display(strFromInfo,"strFromInfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(wDevPlatType, true);
            _ds.displaySimple(pushToken, true);
            _ds.displaySimple(guid, true);
            _ds.displaySimple(devid, true);
            _ds.displaySimple(strFromInfo, false);
            return _os;
        }
    public:
        taf::UInt16 wDevPlatType;
        std::string pushToken;
        std::string guid;
        std::string devid;
        std::string strFromInfo;
    };
    inline bool operator==(const STDevInfo&l, const STDevInfo&r)
    {
        return l.wDevPlatType == r.wDevPlatType && l.pushToken == r.pushToken && l.guid == r.guid && l.devid == r.devid && l.strFromInfo == r.strFromInfo;
    }
    inline bool operator!=(const STDevInfo&l, const STDevInfo&r)
    {
        return !(l == r);
    }

    struct CurLoginToken : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.CurLoginToken";
        }
        static string MD5()
        {
            return "ff7c6c13f2b2900f0ea0eea44c3b1724";
        }
        CurLoginToken()
        :TokenAppID(""),TokenKeyType(0),TokenUin(0),TokenID(""),bMainLogin(false),TokenValueString("")
        {
        }
        void resetDefautlt()
        {
            TokenAppID = "";
            TokenKeyType = 0;
            TokenUin = 0;
            TokenID = "";
            bMainLogin = false;
            TokenValueString = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(TokenAppID, 0);
            _os.write(TokenKeyType, 1);
            _os.write(TokenValue, 2);
            _os.write(TokenUin, 3);
            _os.write(TokenID, 4);
            _os.write(bMainLogin, 5);
            _os.write(TokenValueString, 100);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(TokenAppID, 0, true);
            _is.read(TokenKeyType, 1, true);
            _is.read(TokenValue, 2, true);
            _is.read(TokenUin, 3, false);
            _is.read(TokenID, 4, false);
            _is.read(bMainLogin, 5, false);
            _is.read(TokenValueString, 100, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(TokenAppID,"TokenAppID");
            _ds.display(TokenKeyType,"TokenKeyType");
            _ds.display(TokenValue,"TokenValue");
            _ds.display(TokenUin,"TokenUin");
            _ds.display(TokenID,"TokenID");
            _ds.display(bMainLogin,"bMainLogin");
            _ds.display(TokenValueString,"TokenValueString");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(TokenAppID, true);
            _ds.displaySimple(TokenKeyType, true);
            _ds.displaySimple(TokenValue, true);
            _ds.displaySimple(TokenUin, true);
            _ds.displaySimple(TokenID, true);
            _ds.displaySimple(bMainLogin, true);
            _ds.displaySimple(TokenValueString, false);
            return _os;
        }
    public:
        std::string TokenAppID;
        taf::Char TokenKeyType;
        vector<taf::Char> TokenValue;
        taf::Int64 TokenUin;
        std::string TokenID;
        taf::Bool bMainLogin;
        std::string TokenValueString;
    };
    inline bool operator==(const CurLoginToken&l, const CurLoginToken&r)
    {
        return l.TokenAppID == r.TokenAppID && l.TokenKeyType == r.TokenKeyType && l.TokenValue == r.TokenValue && l.TokenUin == r.TokenUin && l.TokenID == r.TokenID && l.bMainLogin == r.bMainLogin && l.TokenValueString == r.TokenValueString;
    }
    inline bool operator!=(const CurLoginToken&l, const CurLoginToken&r)
    {
        return !(l == r);
    }

    struct STInnerToken : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.STInnerToken";
        }
        static string MD5()
        {
            return "3f0898073d12dcdb041b57b75dcb3fef";
        }
        STInnerToken()
        :ddwVuser(0),vsessionKey(""),dwExpireTime(0)
        {
        }
        void resetDefautlt()
        {
            ddwVuser = 0;
            vsessionKey = "";
            dwExpireTime = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(ddwVuser, 1);
            _os.write(vsessionKey, 2);
            _os.write(dwExpireTime, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ddwVuser, 1, true);
            _is.read(vsessionKey, 2, true);
            _is.read(dwExpireTime, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(ddwVuser,"ddwVuser");
            _ds.display(vsessionKey,"vsessionKey");
            _ds.display(dwExpireTime,"dwExpireTime");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(ddwVuser, true);
            _ds.displaySimple(vsessionKey, true);
            _ds.displaySimple(dwExpireTime, false);
            return _os;
        }
    public:
        taf::Int64 ddwVuser;
        std::string vsessionKey;
        taf::UInt32 dwExpireTime;
    };
    inline bool operator==(const STInnerToken&l, const STInnerToken&r)
    {
        return l.ddwVuser == r.ddwVuser && l.vsessionKey == r.vsessionKey && l.dwExpireTime == r.dwExpireTime;
    }
    inline bool operator!=(const STInnerToken&l, const STInnerToken&r)
    {
        return !(l == r);
    }

    struct WXUserTokenInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.WXUserTokenInfo";
        }
        static string MD5()
        {
            return "ab183b6b7e32205d83bba5623203e8c8";
        }
        WXUserTokenInfo()
        :wxNickName(""),wxFaceImageUrl(""),wxOpenId(""),accessToken(""),refreshToken(""),accessTokenExpireTime(0)
        {
        }
        void resetDefautlt()
        {
            wxNickName = "";
            wxFaceImageUrl = "";
            wxOpenId = "";
            accessToken = "";
            refreshToken = "";
            accessTokenExpireTime = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(wxNickName, 0);
            _os.write(wxFaceImageUrl, 1);
            _os.write(wxOpenId, 2);
            _os.write(accessToken, 3);
            _os.write(refreshToken, 4);
            _os.write(accessTokenExpireTime, 5);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(wxNickName, 0, false);
            _is.read(wxFaceImageUrl, 1, false);
            _is.read(wxOpenId, 2, false);
            _is.read(accessToken, 3, false);
            _is.read(refreshToken, 4, false);
            _is.read(accessTokenExpireTime, 5, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(wxNickName,"wxNickName");
            _ds.display(wxFaceImageUrl,"wxFaceImageUrl");
            _ds.display(wxOpenId,"wxOpenId");
            _ds.display(accessToken,"accessToken");
            _ds.display(refreshToken,"refreshToken");
            _ds.display(accessTokenExpireTime,"accessTokenExpireTime");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(wxNickName, true);
            _ds.displaySimple(wxFaceImageUrl, true);
            _ds.displaySimple(wxOpenId, true);
            _ds.displaySimple(accessToken, true);
            _ds.displaySimple(refreshToken, true);
            _ds.displaySimple(accessTokenExpireTime, false);
            return _os;
        }
    public:
        std::string wxNickName;
        std::string wxFaceImageUrl;
        std::string wxOpenId;
        std::string accessToken;
        std::string refreshToken;
        taf::UInt32 accessTokenExpireTime;
    };
    inline bool operator==(const WXUserTokenInfo&l, const WXUserTokenInfo&r)
    {
        return l.wxNickName == r.wxNickName && l.wxFaceImageUrl == r.wxFaceImageUrl && l.wxOpenId == r.wxOpenId && l.accessToken == r.accessToken && l.refreshToken == r.refreshToken && l.accessTokenExpireTime == r.accessTokenExpireTime;
    }
    inline bool operator!=(const WXUserTokenInfo&l, const WXUserTokenInfo&r)
    {
        return !(l == r);
    }

    struct QQUserTokenInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.QQUserTokenInfo";
        }
        static string MD5()
        {
            return "883109c7af65b97acb816d89d8962e98";
        }
        QQUserTokenInfo()
        :qqNickName(""),qqFaceImageUrl(""),qqUin(""),qqOpenid(""),accessToken(""),refreshToken(""),accessTokenExpireTime(0)
        {
        }
        void resetDefautlt()
        {
            qqNickName = "";
            qqFaceImageUrl = "";
            qqUin = "";
            qqOpenid = "";
            accessToken = "";
            refreshToken = "";
            accessTokenExpireTime = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(qqNickName, 0);
            _os.write(qqFaceImageUrl, 1);
            _os.write(qqUin, 2);
            _os.write(qqOpenid, 3);
            _os.write(accessToken, 4);
            _os.write(refreshToken, 5);
            _os.write(accessTokenExpireTime, 6);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(qqNickName, 0, false);
            _is.read(qqFaceImageUrl, 1, false);
            _is.read(qqUin, 2, false);
            _is.read(qqOpenid, 3, false);
            _is.read(accessToken, 4, false);
            _is.read(refreshToken, 5, false);
            _is.read(accessTokenExpireTime, 6, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(qqNickName,"qqNickName");
            _ds.display(qqFaceImageUrl,"qqFaceImageUrl");
            _ds.display(qqUin,"qqUin");
            _ds.display(qqOpenid,"qqOpenid");
            _ds.display(accessToken,"accessToken");
            _ds.display(refreshToken,"refreshToken");
            _ds.display(accessTokenExpireTime,"accessTokenExpireTime");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(qqNickName, true);
            _ds.displaySimple(qqFaceImageUrl, true);
            _ds.displaySimple(qqUin, true);
            _ds.displaySimple(qqOpenid, true);
            _ds.displaySimple(accessToken, true);
            _ds.displaySimple(refreshToken, true);
            _ds.displaySimple(accessTokenExpireTime, false);
            return _os;
        }
    public:
        std::string qqNickName;
        std::string qqFaceImageUrl;
        std::string qqUin;
        std::string qqOpenid;
        std::string accessToken;
        std::string refreshToken;
        taf::UInt32 accessTokenExpireTime;
    };
    inline bool operator==(const QQUserTokenInfo&l, const QQUserTokenInfo&r)
    {
        return l.qqNickName == r.qqNickName && l.qqFaceImageUrl == r.qqFaceImageUrl && l.qqUin == r.qqUin && l.qqOpenid == r.qqOpenid && l.accessToken == r.accessToken && l.refreshToken == r.refreshToken && l.accessTokenExpireTime == r.accessTokenExpireTime;
    }
    inline bool operator!=(const QQUserTokenInfo&l, const QQUserTokenInfo&r)
    {
        return !(l == r);
    }

    struct StGuidGetRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.StGuidGetRequest";
        }
        static string MD5()
        {
            return "7b395978e0f2cd1b37562323d4c3de7b";
        }
        StGuidGetRequest()
        :iMarketid(0),iPlatform(0),nUnixtime(0)
        {
        }
        void resetDefautlt()
        {
            iMarketid = 0;
            iPlatform = 0;
            nUnixtime = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(iMarketid, 0);
            _os.write(iPlatform, 1);
            _os.write(nUnixtime, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(iMarketid, 0, true);
            _is.read(iPlatform, 1, true);
            _is.read(nUnixtime, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(iMarketid,"iMarketid");
            _ds.display(iPlatform,"iPlatform");
            _ds.display(nUnixtime,"nUnixtime");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(iMarketid, true);
            _ds.displaySimple(iPlatform, true);
            _ds.displaySimple(nUnixtime, false);
            return _os;
        }
    public:
        taf::Int32 iMarketid;
        taf::Int32 iPlatform;
        taf::UInt32 nUnixtime;
    };
    inline bool operator==(const StGuidGetRequest&l, const StGuidGetRequest&r)
    {
        return l.iMarketid == r.iMarketid && l.iPlatform == r.iPlatform && l.nUnixtime == r.nUnixtime;
    }
    inline bool operator!=(const StGuidGetRequest&l, const StGuidGetRequest&r)
    {
        return !(l == r);
    }

    struct StGuidGetResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.StGuidGetResponse";
        }
        static string MD5()
        {
            return "e6701e378b5118a960cc9706ff2e053a";
        }
        StGuidGetResponse()
        :errCode(0),strErrMsg(""),strGuid(""),nUnixtime(0)
        {
        }
        void resetDefautlt()
        {
            errCode = 0;
            strErrMsg = "";
            strGuid = "";
            nUnixtime = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(errCode, 0);
            _os.write(strErrMsg, 1);
            _os.write(strGuid, 2);
            _os.write(nUnixtime, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errCode, 0, true);
            _is.read(strErrMsg, 1, true);
            _is.read(strGuid, 2, true);
            _is.read(nUnixtime, 3, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(errCode,"errCode");
            _ds.display(strErrMsg,"strErrMsg");
            _ds.display(strGuid,"strGuid");
            _ds.display(nUnixtime,"nUnixtime");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(errCode, true);
            _ds.displaySimple(strErrMsg, true);
            _ds.displaySimple(strGuid, true);
            _ds.displaySimple(nUnixtime, false);
            return _os;
        }
    public:
        taf::Int32 errCode;
        std::string strErrMsg;
        std::string strGuid;
        taf::UInt32 nUnixtime;
    };
    inline bool operator==(const StGuidGetResponse&l, const StGuidGetResponse&r)
    {
        return l.errCode == r.errCode && l.strErrMsg == r.strErrMsg && l.strGuid == r.strGuid && l.nUnixtime == r.nUnixtime;
    }
    inline bool operator!=(const StGuidGetResponse&l, const StGuidGetResponse&r)
    {
        return !(l == r);
    }

    struct NewRefreshTokenRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.NewRefreshTokenRequest";
        }
        static string MD5()
        {
            return "41b7749c754973bb8bac2e18ed86ebd8";
        }
        NewRefreshTokenRequest()
        :refreshTypeMask(0)
        {
        }
        void resetDefautlt()
        {
            refreshTypeMask = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(stDevInfo, 1);
            _os.write(vecLoginToken, 2);
            _os.write(refreshTypeMask, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(stDevInfo, 1, false);
            _is.read(vecLoginToken, 2, false);
            _is.read(refreshTypeMask, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(stDevInfo,"stDevInfo");
            _ds.display(vecLoginToken,"vecLoginToken");
            _ds.display(refreshTypeMask,"refreshTypeMask");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(stDevInfo, true);
            _ds.displaySimple(vecLoginToken, true);
            _ds.displaySimple(refreshTypeMask, false);
            return _os;
        }
    public:
        jce::STDevInfo stDevInfo;
        vector<jce::CurLoginToken> vecLoginToken;
        taf::Int32 refreshTypeMask;
    };
    inline bool operator==(const NewRefreshTokenRequest&l, const NewRefreshTokenRequest&r)
    {
        return l.stDevInfo == r.stDevInfo && l.vecLoginToken == r.vecLoginToken && l.refreshTypeMask == r.refreshTypeMask;
    }
    inline bool operator!=(const NewRefreshTokenRequest&l, const NewRefreshTokenRequest&r)
    {
        return !(l == r);
    }

    struct NewRefreshTokenResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.NewRefreshTokenResponse";
        }
        static string MD5()
        {
            return "a45a1968bd2a45d992f204053a69e5f0";
        }
        NewRefreshTokenResponse()
        :errCode(0),strErrMsg("")
        {
        }
        void resetDefautlt()
        {
            errCode = 0;
            strErrMsg = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(errCode, 1);
            _os.write(strErrMsg, 2);
            _os.write(wxUserTokenInfo, 3);
            _os.write(qqUserTokenInfo, 4);
            _os.write(innerToken, 5);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errCode, 1, true);
            _is.read(strErrMsg, 2, true);
            _is.read(wxUserTokenInfo, 3, false);
            _is.read(qqUserTokenInfo, 4, false);
            _is.read(innerToken, 5, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(errCode,"errCode");
            _ds.display(strErrMsg,"strErrMsg");
            _ds.display(wxUserTokenInfo,"wxUserTokenInfo");
            _ds.display(qqUserTokenInfo,"qqUserTokenInfo");
            _ds.display(innerToken,"innerToken");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(errCode, true);
            _ds.displaySimple(strErrMsg, true);
            _ds.displaySimple(wxUserTokenInfo, true);
            _ds.displaySimple(qqUserTokenInfo, true);
            _ds.displaySimple(innerToken, false);
            return _os;
        }
    public:
        taf::UInt32 errCode;
        std::string strErrMsg;
        jce::WXUserTokenInfo wxUserTokenInfo;
        jce::QQUserTokenInfo qqUserTokenInfo;
        jce::STInnerToken innerToken;
    };
    inline bool operator==(const NewRefreshTokenResponse&l, const NewRefreshTokenResponse&r)
    {
        return l.errCode == r.errCode && l.strErrMsg == r.strErrMsg && l.wxUserTokenInfo == r.wxUserTokenInfo && l.qqUserTokenInfo == r.qqUserTokenInfo && l.innerToken == r.innerToken;
    }
    inline bool operator!=(const NewRefreshTokenResponse&l, const NewRefreshTokenResponse&r)
    {
        return !(l == r);
    }

    struct NewLoginRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.NewLoginRequest";
        }
        static string MD5()
        {
            return "27f99942fa60fa5e539a6c967b5396b6";
        }
        NewLoginRequest()
        :from(0),dwAppType(0)
        {
        }
        void resetDefautlt()
        {
            from = 0;
            dwAppType = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(curLoginTokenList, 0);
            _os.write(from, 1);
            _os.write(stDevInfo, 2);
            _os.write(dwAppType, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(curLoginTokenList, 0, false);
            _is.read(from, 1, false);
            _is.read(stDevInfo, 2, false);
            _is.read(dwAppType, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(curLoginTokenList,"curLoginTokenList");
            _ds.display(from,"from");
            _ds.display(stDevInfo,"stDevInfo");
            _ds.display(dwAppType,"dwAppType");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(curLoginTokenList, true);
            _ds.displaySimple(from, true);
            _ds.displaySimple(stDevInfo, true);
            _ds.displaySimple(dwAppType, false);
            return _os;
        }
    public:
        vector<jce::CurLoginToken> curLoginTokenList;
        taf::Int32 from;
        jce::STDevInfo stDevInfo;
        taf::UInt32 dwAppType;
    };
    inline bool operator==(const NewLoginRequest&l, const NewLoginRequest&r)
    {
        return l.curLoginTokenList == r.curLoginTokenList && l.from == r.from && l.stDevInfo == r.stDevInfo && l.dwAppType == r.dwAppType;
    }
    inline bool operator!=(const NewLoginRequest&l, const NewLoginRequest&r)
    {
        return !(l == r);
    }

    struct NewLoginResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.NewLoginResponse";
        }
        static string MD5()
        {
            return "c3819f356a81f09fbc311700bcbd50f5";
        }
        NewLoginResponse()
        :errCode(0),strErrMsg("")
        {
        }
        void resetDefautlt()
        {
            errCode = 0;
            strErrMsg = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(errCode, 0);
            _os.write(innerToken, 1);
            _os.write(wxUserTokenInfo, 2);
            _os.write(qqUserTokenInfo, 3);
            _os.write(strErrMsg, 4);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errCode, 0, true);
            _is.read(innerToken, 1, true);
            _is.read(wxUserTokenInfo, 2, false);
            _is.read(qqUserTokenInfo, 3, false);
            _is.read(strErrMsg, 4, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(errCode,"errCode");
            _ds.display(innerToken,"innerToken");
            _ds.display(wxUserTokenInfo,"wxUserTokenInfo");
            _ds.display(qqUserTokenInfo,"qqUserTokenInfo");
            _ds.display(strErrMsg,"strErrMsg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(errCode, true);
            _ds.displaySimple(innerToken, true);
            _ds.displaySimple(wxUserTokenInfo, true);
            _ds.displaySimple(qqUserTokenInfo, true);
            _ds.displaySimple(strErrMsg, false);
            return _os;
        }
    public:
        taf::Int32 errCode;
        jce::STInnerToken innerToken;
        jce::WXUserTokenInfo wxUserTokenInfo;
        jce::QQUserTokenInfo qqUserTokenInfo;
        std::string strErrMsg;
    };
    inline bool operator==(const NewLoginResponse&l, const NewLoginResponse&r)
    {
        return l.errCode == r.errCode && l.innerToken == r.innerToken && l.wxUserTokenInfo == r.wxUserTokenInfo && l.qqUserTokenInfo == r.qqUserTokenInfo && l.strErrMsg == r.strErrMsg;
    }
    inline bool operator!=(const NewLoginResponse&l, const NewLoginResponse&r)
    {
        return !(l == r);
    }

    struct NewLogoutRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.NewLogoutRequest";
        }
        static string MD5()
        {
            return "01a0c7bc6836df35ca9f663fd41ed621";
        }
        NewLogoutRequest()
        :majorLoginType(0)
        {
        }
        void resetDefautlt()
        {
            majorLoginType = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(majorLoginType, 0);
            _os.write(stDevInfo, 1);
            _os.write(vecLoginToken, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(majorLoginType, 0, true);
            _is.read(stDevInfo, 1, false);
            _is.read(vecLoginToken, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(majorLoginType,"majorLoginType");
            _ds.display(stDevInfo,"stDevInfo");
            _ds.display(vecLoginToken,"vecLoginToken");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(majorLoginType, true);
            _ds.displaySimple(stDevInfo, true);
            _ds.displaySimple(vecLoginToken, false);
            return _os;
        }
    public:
        taf::Int32 majorLoginType;
        jce::STDevInfo stDevInfo;
        vector<jce::CurLoginToken> vecLoginToken;
    };
    inline bool operator==(const NewLogoutRequest&l, const NewLogoutRequest&r)
    {
        return l.majorLoginType == r.majorLoginType && l.stDevInfo == r.stDevInfo && l.vecLoginToken == r.vecLoginToken;
    }
    inline bool operator!=(const NewLogoutRequest&l, const NewLogoutRequest&r)
    {
        return !(l == r);
    }

    struct NewLogoutResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.NewLogoutResponse";
        }
        static string MD5()
        {
            return "26159cf77dcb9fe1c64b57dae580ccae";
        }
        NewLogoutResponse()
        :errCode(0),strErrMsg("")
        {
        }
        void resetDefautlt()
        {
            errCode = 0;
            strErrMsg = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(errCode, 0);
            _os.write(strErrMsg, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errCode, 0, true);
            _is.read(strErrMsg, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(errCode,"errCode");
            _ds.display(strErrMsg,"strErrMsg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(errCode, true);
            _ds.displaySimple(strErrMsg, false);
            return _os;
        }
    public:
        taf::Int32 errCode;
        std::string strErrMsg;
    };
    inline bool operator==(const NewLogoutResponse&l, const NewLogoutResponse&r)
    {
        return l.errCode == r.errCode && l.strErrMsg == r.strErrMsg;
    }
    inline bool operator!=(const NewLogoutResponse&l, const NewLogoutResponse&r)
    {
        return !(l == r);
    }

    struct NewGetTicketRequest : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.NewGetTicketRequest";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        NewGetTicketRequest()
        :wxAppID("")
        {
        }
        void resetDefautlt()
        {
            wxAppID = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(wxAppID, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(wxAppID, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(wxAppID,"wxAppID");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(wxAppID, false);
            return _os;
        }
    public:
        std::string wxAppID;
    };
    inline bool operator==(const NewGetTicketRequest&l, const NewGetTicketRequest&r)
    {
        return l.wxAppID == r.wxAppID;
    }
    inline bool operator!=(const NewGetTicketRequest&l, const NewGetTicketRequest&r)
    {
        return !(l == r);
    }

    struct NewGetTicketResponse : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "jce.NewGetTicketResponse";
        }
        static string MD5()
        {
            return "e6701e378b5118a960cc9706ff2e053a";
        }
        NewGetTicketResponse()
        :errCode(0),strErrMsg(""),ticket(""),ticketExpireTime(0)
        {
        }
        void resetDefautlt()
        {
            errCode = 0;
            strErrMsg = "";
            ticket = "";
            ticketExpireTime = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(errCode, 0);
            _os.write(strErrMsg, 1);
            _os.write(ticket, 2);
            _os.write(ticketExpireTime, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(errCode, 0, true);
            _is.read(strErrMsg, 1, false);
            _is.read(ticket, 2, false);
            _is.read(ticketExpireTime, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(errCode,"errCode");
            _ds.display(strErrMsg,"strErrMsg");
            _ds.display(ticket,"ticket");
            _ds.display(ticketExpireTime,"ticketExpireTime");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(errCode, true);
            _ds.displaySimple(strErrMsg, true);
            _ds.displaySimple(ticket, true);
            _ds.displaySimple(ticketExpireTime, false);
            return _os;
        }
    public:
        taf::Int32 errCode;
        std::string strErrMsg;
        std::string ticket;
        taf::UInt32 ticketExpireTime;
    };
    inline bool operator==(const NewGetTicketResponse&l, const NewGetTicketResponse&r)
    {
        return l.errCode == r.errCode && l.strErrMsg == r.strErrMsg && l.ticket == r.ticket && l.ticketExpireTime == r.ticketExpireTime;
    }
    inline bool operator!=(const NewGetTicketResponse&l, const NewGetTicketResponse&r)
    {
        return !(l == r);
    }


}

#define jce_STDevInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.wDevPlatType,b.wDevPlatType);jce_copy_struct(a.pushToken,b.pushToken);jce_copy_struct(a.guid,b.guid);jce_copy_struct(a.devid,b.devid);jce_copy_struct(a.strFromInfo,b.strFromInfo);

#define jce_CurLoginToken_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.TokenAppID,b.TokenAppID);jce_copy_struct(a.TokenKeyType,b.TokenKeyType);jce_copy_struct(a.TokenValue,b.TokenValue);jce_copy_struct(a.TokenUin,b.TokenUin);jce_copy_struct(a.TokenID,b.TokenID);jce_copy_struct(a.bMainLogin,b.bMainLogin);jce_copy_struct(a.TokenValueString,b.TokenValueString);

#define jce_STInnerToken_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.ddwVuser,b.ddwVuser);jce_copy_struct(a.vsessionKey,b.vsessionKey);jce_copy_struct(a.dwExpireTime,b.dwExpireTime);

#define jce_WXUserTokenInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.wxNickName,b.wxNickName);jce_copy_struct(a.wxFaceImageUrl,b.wxFaceImageUrl);jce_copy_struct(a.wxOpenId,b.wxOpenId);jce_copy_struct(a.accessToken,b.accessToken);jce_copy_struct(a.refreshToken,b.refreshToken);jce_copy_struct(a.accessTokenExpireTime,b.accessTokenExpireTime);

#define jce_QQUserTokenInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.qqNickName,b.qqNickName);jce_copy_struct(a.qqFaceImageUrl,b.qqFaceImageUrl);jce_copy_struct(a.qqUin,b.qqUin);jce_copy_struct(a.qqOpenid,b.qqOpenid);jce_copy_struct(a.accessToken,b.accessToken);jce_copy_struct(a.refreshToken,b.refreshToken);jce_copy_struct(a.accessTokenExpireTime,b.accessTokenExpireTime);

#define jce_StGuidGetRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.iMarketid,b.iMarketid);jce_copy_struct(a.iPlatform,b.iPlatform);jce_copy_struct(a.nUnixtime,b.nUnixtime);

#define jce_StGuidGetResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.errCode,b.errCode);jce_copy_struct(a.strErrMsg,b.strErrMsg);jce_copy_struct(a.strGuid,b.strGuid);jce_copy_struct(a.nUnixtime,b.nUnixtime);

#define jce_NewRefreshTokenRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.stDevInfo,b.stDevInfo);jce_copy_struct(a.vecLoginToken,b.vecLoginToken);jce_copy_struct(a.refreshTypeMask,b.refreshTypeMask);

#define jce_NewRefreshTokenResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.errCode,b.errCode);jce_copy_struct(a.strErrMsg,b.strErrMsg);jce_copy_struct(a.wxUserTokenInfo,b.wxUserTokenInfo);jce_copy_struct(a.qqUserTokenInfo,b.qqUserTokenInfo);jce_copy_struct(a.innerToken,b.innerToken);

#define jce_NewLoginRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.curLoginTokenList,b.curLoginTokenList);jce_copy_struct(a.from,b.from);jce_copy_struct(a.stDevInfo,b.stDevInfo);jce_copy_struct(a.dwAppType,b.dwAppType);

#define jce_NewLoginResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.errCode,b.errCode);jce_copy_struct(a.innerToken,b.innerToken);jce_copy_struct(a.wxUserTokenInfo,b.wxUserTokenInfo);jce_copy_struct(a.qqUserTokenInfo,b.qqUserTokenInfo);jce_copy_struct(a.strErrMsg,b.strErrMsg);

#define jce_NewLogoutRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.majorLoginType,b.majorLoginType);jce_copy_struct(a.stDevInfo,b.stDevInfo);jce_copy_struct(a.vecLoginToken,b.vecLoginToken);

#define jce_NewLogoutResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.errCode,b.errCode);jce_copy_struct(a.strErrMsg,b.strErrMsg);

#define jce_NewGetTicketRequest_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.wxAppID,b.wxAppID);

#define jce_NewGetTicketResponse_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.errCode,b.errCode);jce_copy_struct(a.strErrMsg,b.strErrMsg);jce_copy_struct(a.ticket,b.ticket);jce_copy_struct(a.ticketExpireTime,b.ticketExpireTime);



#endif
